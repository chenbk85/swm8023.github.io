<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>LeetCode题解整理版(二) | Coding 4 Fun</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="本篇题解中共96题，都是用Python写的，按照Leetcode上的顺序从上向下。可以用CTRL+F查找，如果没有的话就是在前一篇题解中了。">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode题解整理版(二)">
<meta property="og:url" content="http://vimersu.win/blog/2014/03/20/leetcode-solution-02/index.html">
<meta property="og:site_name" content="Coding 4 Fun">
<meta property="og:description" content="本篇题解中共96题，都是用Python写的，按照Leetcode上的顺序从上向下。可以用CTRL+F查找，如果没有的话就是在前一篇题解中了。">
<meta property="og:updated_time" content="2016-06-04T14:57:29.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeetCode题解整理版(二)">
<meta name="twitter:description" content="本篇题解中共96题，都是用Python写的，按照Leetcode上的顺序从上向下。可以用CTRL+F查找，如果没有的话就是在前一篇题解中了。">
  
    <link rel="alternative" href="/atom.xml" title="Coding 4 Fun" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>
<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="/avator.jpg" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/">Vimer Su</a></h1>
        </hgroup>

        
        <p class="header-subtitle">Dream it, Believe it, Do IT!</p>
        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">博客首页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl mail" target="_blank" href="mailto:swm8023@gmail.com" title="mail">mail</a>
                            
                                <a class="fl github" target="_blank" href="https://github.com/swm8023" title="github">github</a>
                            
                                <a class="fl rss" target="_blank" href="/atom.xml" title="rss">rss</a>
                            
                                <a class="fl douban" target="_blank" href="https://www.douban.com/people/swm8023/" title="douban">douban</a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/AP/" style="font-size: 10px;">AP</a> <a href="/tags/Alcatraz/" style="font-size: 10px;">Alcatraz</a> <a href="/tags/Algorithm/" style="font-size: 17.5px;">Algorithm</a> <a href="/tags/Apache/" style="font-size: 10px;">Apache</a> <a href="/tags/C/" style="font-size: 15px;">C</a> <a href="/tags/Cmockery/" style="font-size: 10px;">Cmockery</a> <a href="/tags/DirectX-3D/" style="font-size: 12.5px;">DirectX 3D</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/I-O复用/" style="font-size: 10px;">I/O复用</a> <a href="/tags/Leetcode-OJ/" style="font-size: 15px;">Leetcode OJ</a> <a href="/tags/Libev/" style="font-size: 10px;">Libev</a> <a href="/tags/Linux/" style="font-size: 20px;">Linux</a> <a href="/tags/MAC/" style="font-size: 10px;">MAC</a> <a href="/tags/Makefile/" style="font-size: 15px;">Makefile</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/OSX/" style="font-size: 10px;">OSX</a> <a href="/tags/Octopress/" style="font-size: 12.5px;">Octopress</a> <a href="/tags/OpenGL/" style="font-size: 10px;">OpenGL</a> <a href="/tags/Proxy/" style="font-size: 10px;">Proxy</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Sublime-text3/" style="font-size: 10px;">Sublime text3</a> <a href="/tags/Tools/" style="font-size: 10px;">Tools</a> <a href="/tags/Vim/" style="font-size: 10px;">Vim</a> <a href="/tags/Xcode/" style="font-size: 10px;">Xcode</a> <a href="/tags/epoll/" style="font-size: 10px;">epoll</a> <a href="/tags/iconv/" style="font-size: 10px;">iconv</a> <a href="/tags/madwifi/" style="font-size: 12.5px;">madwifi</a> <a href="/tags/wlanconfig/" style="font-size: 10px;">wlanconfig</a> <a href="/tags/二叉树/" style="font-size: 10px;">二叉树</a> <a href="/tags/单元测试/" style="font-size: 10px;">单元测试</a> <a href="/tags/堆/" style="font-size: 10px;">堆</a> <a href="/tags/外接显示器/" style="font-size: 10px;">外接显示器</a> <a href="/tags/天天爱消除/" style="font-size: 10px;">天天爱消除</a> <a href="/tags/宏/" style="font-size: 10px;">宏</a> <a href="/tags/正则表达式/" style="font-size: 10px;">正则表达式</a> <a href="/tags/游戏开发/" style="font-size: 12.5px;">游戏开发</a> <a href="/tags/线程同步/" style="font-size: 10px;">线程同步</a> <a href="/tags/结构体/" style="font-size: 10px;">结构体</a> <a href="/tags/驱动程序/" style="font-size: 12.5px;">驱动程序</a>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/swm8023">swm8023@github</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.csdn.net/swm8023">swm8023@csdn</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.cnblogs.com/swm8023/">swm8023@cnblogs</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.cnblogs.com/CSGrandeur/">CSGrandeur</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://hujiaweibujidao.github.io/">Hujiawei Bujidao</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.chinaunix.net/uid/28387257.html">Henrystark&#39;s CU blog</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://oxoo.org">OxOo社</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.cnblogs.com/staginner/">Staginner</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://zhangxc.com/">张学程</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://yangha.github.io/">小阳Space</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">Hello World</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Vimer Su</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/avator.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Vimer Su</a></h1>
            </hgroup>
            
            <p class="header-subtitle">Dream it, Believe it, Do IT!</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">博客首页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="mail" target="_blank" href="mailto:swm8023@gmail.com" title="mail">mail</a>
                    
                        <a class="github" target="_blank" href="https://github.com/swm8023" title="github">github</a>
                    
                        <a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
                    
                        <a class="douban" target="_blank" href="https://www.douban.com/people/swm8023/" title="douban">douban</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap"><article id="post-leetcode-solution-02" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2014/03/20/leetcode-solution-02/" class="article-date">
      <time datetime="2014-03-20T05:49:04.000Z" itemprop="datePublished">2014-03-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      LeetCode题解整理版(二)
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Leetcode-OJ/">Leetcode OJ</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>Leetcode开始支持Python了，本篇题解中的题目都是用Python写的。<del>（更新中..）</del>  </p>
<p><strong>已更新完</strong>，本篇题解中共96题，按照Leetcode上的顺序从上向下。可以用CTRL+F查找，如果没有的话就是在前一篇题解中了。  </p>
<p>因为时间原因，题解写的并不是很详细，大多数题目都只给出了关键思路。  </p>
<a id="more"></a>
<h2 id="Reverse-Words-in-a-String"><a href="#Reverse-Words-in-a-String" class="headerlink" title="Reverse Words in a String"></a><strong>Reverse Words in a String</strong></h2><p>将abc def形式的字符串翻转成def abc，并且去掉多余的空格。<br>先将这个字符串翻转过来，再逐次翻转每个词。（当然不是效率最高的办法，只是为了好写。）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param s, a string</span></span><br><span class="line">    <span class="comment"># @return a string</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>.join([word[::<span class="number">-1</span>] <span class="keyword">for</span> word <span class="keyword">in</span> s[::<span class="number">-1</span>].split()])</span><br></pre></td></tr></table></figure></p>
<h2 id="Recover-Binary-Search-Tree"><a href="#Recover-Binary-Search-Tree" class="headerlink" title="Recover Binary Search Tree"></a><strong>Recover Binary Search Tree</strong></h2><p>一棵二叉搜索树中两个节点错误，修正这棵树。<br>正确二叉树中序遍历应该是递增，而交换了两个节点后会导致有<strong>一处或者两处</strong>某节点值小于前一个节点，记录，最后交换即可。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param root, a tree node</span></span><br><span class="line">    <span class="comment"># @return a tree node</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recoverTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        self.pre = <span class="keyword">None</span></span><br><span class="line">        self.n1 = self.n2 = <span class="keyword">None</span></span><br><span class="line">        self.dfs(root)</span><br><span class="line">        self.n1.val, self.n2.val = self.n2.val, self.n1.val</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.dfs(root.left)</span><br><span class="line">        <span class="keyword">if</span> self.pre <span class="keyword">and</span> root.val &lt; self.pre.val:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.n1:</span><br><span class="line">                self.n1, self.n2 = self.pre, root</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.n2 = root</span><br><span class="line">        self.pre = root</span><br><span class="line">        self.dfs(root.right)</span><br></pre></td></tr></table></figure></p>
<h2 id="Validate-Binary-Search-Tree"><a href="#Validate-Binary-Search-Tree" class="headerlink" title="Validate Binary Search Tree"></a><strong>Validate Binary Search Tree</strong></h2><p>判断是否是BST<br>中序遍历，比较当前点的值是否大于前一点的值即可<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param root, a tree node</span></span><br><span class="line">    <span class="comment"># @return a boolean</span></span><br><span class="line">    val = <span class="keyword">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        res = self.isValidBST(root.left)</span><br><span class="line">        <span class="keyword">if</span> self.val <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            self.val = root.val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res = res <span class="keyword">and</span> (root.val &gt; self.val)</span><br><span class="line">            self.val = root.val</span><br><span class="line">        res = res <span class="keyword">and</span> self.isValidBST(root.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2 id="Interleaving-String"><a href="#Interleaving-String" class="headerlink" title="Interleaving String"></a><strong>Interleaving String</strong></h2><p>判断C串是否有A串和B串组成（就是说C中提取出A之后剩下B）<br>简单DP，<code>dp[i][j]</code>表示A[1..i]和B[1..j]是否可以组成C[1..i+j]<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return a boolean</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isInterleave</span><span class="params">(self, s1, s2, s3)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(s3) != len(s1) + len(s2):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        dp = [[<span class="keyword">False</span>] * (len(s2) + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s1) + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s1) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(s2) + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> j == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">elif</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> dp[i<span class="number">-1</span>][j] <span class="keyword">and</span> s3[i+j<span class="number">-1</span>] == s1[i<span class="number">-1</span>]:</span><br><span class="line">                    dp[i][j] = <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">elif</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> dp[i][j<span class="number">-1</span>] <span class="keyword">and</span> s3[i+j<span class="number">-1</span>] == s2[j<span class="number">-1</span>]:</span><br><span class="line">                    dp[i][j] = <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> dp[len(s1)][len(s2)]</span><br></pre></td></tr></table></figure></p>
<h2 id="Unique-Binary-Search-Trees-II"><a href="#Unique-Binary-Search-Trees-II" class="headerlink" title="Unique Binary Search Trees II"></a><strong>Unique Binary Search Trees II</strong></h2><p>给出N个节点二叉搜索树的所有形态。<br>要生成所有形态，也只有暴力枚举了。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return a list of tree node</span></span><br><span class="line">    treelist = <span class="keyword">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.dfs(<span class="number">0</span>, n)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, l, r)</span>:</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">if</span> l == r:</span><br><span class="line">            ans.append(<span class="keyword">None</span>)</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l, r):</span><br><span class="line">            lb, rb = self.dfs(l, i), self.dfs(i + <span class="number">1</span>, r)</span><br><span class="line">            <span class="keyword">for</span> lc <span class="keyword">in</span> lb:</span><br><span class="line">                <span class="keyword">for</span> rc <span class="keyword">in</span> rb:</span><br><span class="line">                    node = TreeNode(i + <span class="number">1</span>)</span><br><span class="line">                    node.left = lc</span><br><span class="line">                    node.right = rc</span><br><span class="line">                    ans.append(node)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<h2 id="Reverse-Linked-List-II"><a href="#Reverse-Linked-List-II" class="headerlink" title="Reverse Linked List II"></a><strong>Reverse Linked List II</strong></h2><p>翻转链表的中间一段，要求常数空间，只遍历一遍<br>记录下第m个节点和它的前一个节点，中间直接翻，到第n个节点再进行一些处理。思想简单但很容易写错。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param head, a ListNode</span></span><br><span class="line">    <span class="comment"># @param m, an integer</span></span><br><span class="line">    <span class="comment"># @param n, an integer</span></span><br><span class="line">    <span class="comment"># @return a ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head, m, n)</span>:</span></span><br><span class="line">        prem, pre, next, now, nowm = <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, head, <span class="keyword">None</span>;</span><br><span class="line">        ind = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> now <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            next = now.next</span><br><span class="line">            <span class="keyword">if</span> ind &gt;= m <span class="keyword">and</span> ind &lt;= n:</span><br><span class="line">                now.next = pre</span><br><span class="line">            <span class="keyword">if</span> ind == m:</span><br><span class="line">                prem, nowm = pre, now</span><br><span class="line">            <span class="keyword">if</span> ind == n:</span><br><span class="line">                nowm.next = next</span><br><span class="line">                <span class="keyword">if</span> prem <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">                    head = now</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    prem.next = now</span><br><span class="line">            pre, now, ind = now, next, ind + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></p>
<h2 id="Subsets-II"><a href="#Subsets-II" class="headerlink" title="Subsets II"></a><strong>Subsets II</strong></h2><p>枚举一个集合中的不重复子集<br>既然枚举子集，想必题目中的集合不会有多少数，可以用二进制数来表示某个数选了没有，因为要保证不重复，所以对集合排序后，连续相同的数不能选相同数目，我们可以规定对于相同数，如果前面一个没选，后面一个就不能选来保证这一点。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param num, a list of integer</span></span><br><span class="line">    <span class="comment"># @return a list of lists of integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        S.sort()</span><br><span class="line">        bset = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">2</span>**len(S)):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(S)):</span><br><span class="line">                <span class="keyword">if</span> (S[i] == S[i<span class="number">-1</span>] <span class="keyword">and</span> (x&gt;&gt;(i<span class="number">-1</span>)&amp;<span class="number">0x03</span> == <span class="number">0x01</span>)): <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                bset.append(x)</span><br><span class="line">        <span class="keyword">return</span> [[S[x] <span class="keyword">for</span> x <span class="keyword">in</span> range(len(S)) <span class="keyword">if</span> i&gt;&gt;x&amp;<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> bset]</span><br></pre></td></tr></table></figure></p>
<h2 id="Decode-Ways"><a href="#Decode-Ways" class="headerlink" title="Decode Ways"></a><strong>Decode Ways</strong></h2><p>1-&gt;A..26-&gt;Z一一对应，给一个数字串，问有多少种解码方式。<br>动态规划，S[i]表示到i位有多少种组合方式，其值决定与S[i-1]与S[i-2]。<br><code>S[i] = if(S[i] ok) S[i-1] + if (S[i-1..i] ok) S[i-2]</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param s, a string</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">1</span>] + [<span class="number">0</span>] * len(s)</span><br><span class="line">        ok = <span class="keyword">lambda</span> x: x[<span class="number">0</span>] != <span class="string">'0'</span> <span class="keyword">and</span>  int(x) &gt;= <span class="number">1</span> <span class="keyword">and</span> int(x) &lt;= <span class="number">26</span>;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s) + <span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] <span class="keyword">if</span> ok(s[i<span class="number">-1</span>:i]) <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= <span class="number">2</span>:</span><br><span class="line">                dp[i]+= dp[i<span class="number">-2</span>] <span class="keyword">if</span> ok(s[i<span class="number">-2</span>:i]) <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> dp[len(s)]</span><br></pre></td></tr></table></figure></p>
<h2 id="GrayCode"><a href="#GrayCode" class="headerlink" title="GrayCode"></a><strong>GrayCode</strong></h2><p>排列0~2^N-1个二进制串，相邻串之间只有一位不同。<br>可以这样考虑，假设N-1的问题已经解决，已经有2^(N-1)个串符合条件，现在解决N的问题，那么还要再生成2^(N-1)个串，很显然，这后2^(N-1)个的最高位都为1，所以只要考虑其余N-1位即可。第2^(N-1)+1个串只能在第2^(N-1)个串的最高位加个1，然后我们又知道第2^(N-1)-1和第2^(N-1)个只差一位，所以第2^(N-1)+2个串只要在第2^(N-1)-1个串的第N位加个1，以此类推。  </p>
<p>下面给个例子，很容易看懂<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">000 0</span><br><span class="line">001 1</span><br><span class="line">011 3</span><br><span class="line">010 2</span><br><span class="line">----后两位以此为对称轴</span><br><span class="line">110 6</span><br><span class="line">111 7</span><br><span class="line">101 5</span><br><span class="line">100 4</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return a list of integers</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grayCode</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.res = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">2</span>**x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, n)]:</span><br><span class="line">            self.res.append(self.res[<span class="number">-1</span>] + i)</span><br><span class="line">            self.res.extend([i + v <span class="keyword">for</span> v <span class="keyword">in</span> self.res[<span class="number">-3</span>:<span class="keyword">None</span>:<span class="number">-1</span>]])</span><br><span class="line">        <span class="keyword">return</span> self.res;</span><br></pre></td></tr></table></figure>
<h2 id="Merge-Sorted-Array"><a href="#Merge-Sorted-Array" class="headerlink" title="Merge Sorted Array"></a><strong>Merge Sorted Array</strong></h2><p>合并A、B两个有序数组到A中。<br>从前向后放不行，那就从后向前放吧<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param A  a list of integers</span></span><br><span class="line">    <span class="comment"># @param m  an integer, length of A</span></span><br><span class="line">    <span class="comment"># @param B  a list of integers</span></span><br><span class="line">    <span class="comment"># @param n  an integer, length of B</span></span><br><span class="line">    <span class="comment"># @return nothing</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, A, m, B, n)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m + n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> m == <span class="number">0</span> <span class="keyword">or</span> (n &gt; <span class="number">0</span> <span class="keyword">and</span> B[n<span class="number">-1</span>] &gt; A[m<span class="number">-1</span>]):</span><br><span class="line">                A[i] = B[n<span class="number">-1</span>]</span><br><span class="line">                n -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                A[i] = A[m<span class="number">-1</span>]</span><br><span class="line">                m -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure></p>
<h2 id="Scramble-String"><a href="#Scramble-String" class="headerlink" title="Scramble String"></a><strong>Scramble String</strong></h2><p><a href="题目链接">http://oj.leetcode.com/problems/scramble-string/</a><br>动态规划，用dp[lp][rp][len]表示s1[lp:lp+len]和s2[rp:lp+len]是Scramble String。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return a boolean</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isScramble</span><span class="params">(self, s1, s2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(s1) != len(s2):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> len(s1) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        self.s1, self.s2 = s1, s2</span><br><span class="line">        lens = len(s1)</span><br><span class="line">        self.dp = [[[<span class="number">-1</span>] * lens <span class="keyword">for</span> i <span class="keyword">in</span> range(lens)] * lens <span class="keyword">for</span> i <span class="keyword">in</span> range(lens)]</span><br><span class="line">        <span class="keyword">return</span> self.dfs(<span class="number">0</span>, <span class="number">0</span>, len(s1))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, lp, rp, len)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.dp[lp][rp][len - <span class="number">1</span>] &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> self.dp[lp][rp][len - <span class="number">1</span>] == <span class="number">1</span> <span class="keyword">else</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> len == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.s1[lp] == self.s2[rp]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len):</span><br><span class="line">            <span class="keyword">if</span> self.dfs(lp, rp, i) <span class="keyword">and</span> self.dfs(lp + i, rp + i, len - i) \</span><br><span class="line">                    <span class="keyword">or</span> self.dfs(lp, rp + i, len - i) <span class="keyword">and</span> self.dfs(lp + len - i, rp, i):</span><br><span class="line">                self.dp[lp][rp][len - <span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        self.dp[lp][rp][len - <span class="number">1</span>] = <span class="number">0</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Partition-List"><a href="#Partition-List" class="headerlink" title="Partition List"></a><strong>Partition List</strong></h2><p>给定一个值，将链表中按该值分为前后两部分，要求保持原序。<br>拖两条链，一条大值链一条小值链，最后连起来即可。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param head, a ListNode</span></span><br><span class="line">    <span class="comment"># @param x, an integer</span></span><br><span class="line">    <span class="comment"># @return a ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, head, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        sHead, bHead = ListNode(<span class="number">0</span>), ListNode(<span class="number">0</span>)</span><br><span class="line">        sTail, bTail = sHead, bHead</span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">if</span> head.val &lt; x:</span><br><span class="line">                sTail.next = head</span><br><span class="line">                sTail = sTail.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                bTail.next = head</span><br><span class="line">                bTail = bTail.next</span><br><span class="line">            head = head.next</span><br><span class="line">        bTail.next = <span class="keyword">None</span></span><br><span class="line">        sTail.next = bHead.next</span><br><span class="line">        <span class="keyword">return</span> sHead.next</span><br></pre></td></tr></table></figure></p>
<h2 id="Maximal-Rectangle"><a href="#Maximal-Rectangle" class="headerlink" title="Maximal Rectangle"></a><strong>Maximal Rectangle</strong></h2><p>给出0、1矩阵，找出最大的由1构成的矩阵。<br>就是对每一行依次用单调栈求以这行为底的最大矩形，最后取最大的就可以了，单调栈的解释见下一题。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param matrix, a list of lists of 1 length string</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalRectangle</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(matrix) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">            stk = []</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>]) + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &lt; len(matrix[<span class="number">0</span>]): matrix[i][j] = int(matrix[i][j])</span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> j &lt; len(matrix[<span class="number">0</span>]) <span class="keyword">and</span> matrix[i][j]:</span><br><span class="line">                    matrix[i][j] += matrix[i<span class="number">-1</span>][j]</span><br><span class="line">                <span class="keyword">while</span> len(stk) <span class="keyword">and</span> (j == len(matrix[<span class="number">0</span>]) <span class="keyword">or</span> matrix[i][stk[<span class="number">-1</span>]] &gt;= matrix[i][j]):</span><br><span class="line">                    top = stk.pop()</span><br><span class="line">                    <span class="keyword">if</span> len(stk) == <span class="number">0</span>:</span><br><span class="line">                        ans = max(ans, matrix[i][top]*j)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        ans = max(ans, matrix[i][top]*(j-stk[<span class="number">-1</span>]<span class="number">-1</span>))</span><br><span class="line">                stk.append(j)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<h2 id="Largest-Rectangle-in-Histogram"><a href="#Largest-Rectangle-in-Histogram" class="headerlink" title="Largest Rectangle in Histogram"></a><strong>Largest Rectangle in Histogram</strong></h2><p>N块宽度相同，高度不同的木板连在一起，求最大矩形。<br>首先，我们知道暴力的方法，就是枚举每个木板作为它所在矩形最大高度，然后看最左和最右分别能延伸多长，复杂度O(N^2)。<br>基于暴力方法可以用单调栈优化，从左向右扫，同时入栈，入栈前将栈顶比它短的木板全部出栈，每个木板在出栈时计算以它为所在矩形最大高度的矩形的最大面积。每个木板入栈出栈各一次，复杂度O(n)。<br>其实不难理解，每个木板出栈时它(栈的)下面那块木板就是左边第一块比它短的，而使它出栈的那块木板则是右边第一块比它短的，也就很快找到了上面暴力方法中最左和最右能延伸的距离。<br>代码要注意细节处理。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param height, a list of integer</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, height)</span>:</span></span><br><span class="line">        ans, lenh, stk = <span class="number">0</span>, len(height), []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(lenh + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">while</span> len(stk) <span class="keyword">and</span> (i == lenh <span class="keyword">or</span> height[stk[<span class="number">-1</span>]] &gt;= height[i]):</span><br><span class="line">                top = stk.pop()</span><br><span class="line">                <span class="keyword">if</span> len(stk) == <span class="number">0</span>:</span><br><span class="line">                    ans = max(ans, height[top] * i)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans = max(ans, height[top] * (i - stk[<span class="number">-1</span>] - <span class="number">1</span>))</span><br><span class="line">            stk.append(i)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<h2 id="Remove-Duplicates-from-Sorted-List-II"><a href="#Remove-Duplicates-from-Sorted-List-II" class="headerlink" title="Remove Duplicates from Sorted List II"></a><strong>Remove Duplicates from Sorted List II</strong></h2><p>删除有序链表中的重复元素。<br>注意处理细节，首先，当一个元素的后两个连续节点值相同时删除下一个，其次，当后两个连续节点不同但上一次是删除操作时也要删除下一个，然后更改标记不继续删后面的。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param head, a ListNode</span></span><br><span class="line">    <span class="comment"># @return a ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        nHead, flag = ListNode(<span class="number">0</span>), <span class="keyword">False</span></span><br><span class="line">        nHead.next, head = head, nHead</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> (head.next <span class="keyword">and</span> head.next.next <span class="keyword">and</span> head.next.next.val == head.next.val):</span><br><span class="line">                head.next = head.next.next</span><br><span class="line">                flag = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">elif</span> flag == <span class="keyword">True</span> <span class="keyword">and</span> head.next:</span><br><span class="line">                head.next = head.next.next</span><br><span class="line">                flag = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                head = head.next</span><br><span class="line">        <span class="keyword">return</span> nHead.next</span><br></pre></td></tr></table></figure></p>
<h2 id="Remove-Duplicates-from-Sorted-List"><a href="#Remove-Duplicates-from-Sorted-List" class="headerlink" title="Remove Duplicates from Sorted List"></a><strong>Remove Duplicates from Sorted List</strong></h2><p>有序链表中若有多个元素重复，只保持一个。<br>比上题简单，标记都省了。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param head, a ListNode</span></span><br><span class="line">    <span class="comment"># @return a ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        nHead = ListNode(<span class="number">0</span>)</span><br><span class="line">        nHead.next, head = head, nHead</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> (head.next <span class="keyword">and</span> head.next.next <span class="keyword">and</span> head.next.next.val == head.next.val):</span><br><span class="line">                head.next = head.next.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                head = head.next</span><br><span class="line">        <span class="keyword">return</span> nHead.next</span><br></pre></td></tr></table></figure></p>
<h2 id="Search-in-Rotated-Sorted-Array-II"><a href="#Search-in-Rotated-Sorted-Array-II" class="headerlink" title="Search in Rotated Sorted Array II"></a><strong>Search in Rotated Sorted Array II</strong></h2><p>一个有序数组循环右移若干后位之后，在之中搜索一个值。<br>在普通二分上做修改，需要注意的是A[l]=A[m]=A[n]时，无法知道往那边搜索，最坏复杂度可能有O(N)。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param A a list of integers</span></span><br><span class="line">    <span class="comment"># @param target an integer</span></span><br><span class="line">    <span class="comment"># @return a boolean</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, A, target)</span>:</span></span><br><span class="line">        l, h = <span class="number">0</span>, len(A) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= h):</span><br><span class="line">            m = l + ((h - l) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> A[m] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> A[m] == A[l] <span class="keyword">and</span> A[m] == A[h]:</span><br><span class="line">                l, h = l + <span class="number">1</span>, h - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> (A[m] &gt; A[l] <span class="keyword">and</span> target &lt; A[m] <span class="keyword">and</span> target &gt;= A[l]) <span class="keyword">or</span> (A[m] &lt; A[l] <span class="keyword">and</span> <span class="keyword">not</span> (target &lt;= A[h] <span class="keyword">and</span> target &gt; A[m])):</span><br><span class="line">                h = m - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = m + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Remove-Duplicates-from-Sorted-Array-II"><a href="#Remove-Duplicates-from-Sorted-Array-II" class="headerlink" title="Remove Duplicates from Sorted Array II"></a><strong>Remove Duplicates from Sorted Array II</strong></h2><p>有序数组中的若有多个元素重复，只保持两个。<br>没做I的时候我用的是POP元素。。和I一样，往数组前段放就可以了，保证已放的重复元素不超过两个<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param A a list of integers</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        sz = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            <span class="keyword">if</span> sz &lt; <span class="number">2</span> <span class="keyword">or</span> A[sz - <span class="number">2</span>] != A[i]:</span><br><span class="line">                A[sz] = A[i]</span><br><span class="line">                sz = sz + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> sz</span><br></pre></td></tr></table></figure></p>
<h2 id="Word-Search"><a href="#Word-Search" class="headerlink" title="Word Search"></a><strong>Word Search</strong></h2><p>在一个矩阵中找一个单词。<br>暴力DFS。(我能说我一个暴力DFS写了半天么(┬＿┬))<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param board, a list of lists of 1 length string</span></span><br><span class="line">    <span class="comment"># @param word, a string</span></span><br><span class="line">    <span class="comment"># @return a boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board, word)</span>:</span></span><br><span class="line">        self.h = len(board)</span><br><span class="line">        self.w = len(board[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.h):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(self.w):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == word[<span class="number">0</span>]:</span><br><span class="line">                    t, board[i][j] = board[i][j], <span class="string">' '</span></span><br><span class="line">                    <span class="keyword">if</span> self.dfs(board, word, i, j, <span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                    board[i][j] = t</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, board, word, x, y, p)</span>:</span></span><br><span class="line">        dx, dy = [<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> (p == len(word)):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            nx, ny = x + dx[i], y + dy[i]</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= nx <span class="keyword">and</span> nx &lt; self.h <span class="keyword">and</span> <span class="number">0</span> &lt;= ny <span class="keyword">and</span> ny &lt; self.w <span class="keyword">and</span> board[nx][ny] == word[p]:</span><br><span class="line">                t, board[nx][ny] = board[nx][ny], <span class="string">' '</span></span><br><span class="line">                <span class="keyword">if</span> self.dfs(board, word, nx, ny, p + <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                board[nx][ny] = t</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Subsets"><a href="#Subsets" class="headerlink" title="Subsets"></a><strong>Subsets</strong></h2><p>枚举所有子集。<br>二进制表示选了哪些数。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param S, a list of integer</span></span><br><span class="line">    <span class="comment"># @return a list of lists of integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        S.sort()</span><br><span class="line">        <span class="keyword">return</span> [[S[x] <span class="keyword">for</span> x <span class="keyword">in</span> range(len(S)) <span class="keyword">if</span> i&gt;&gt;x&amp;<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>**len(S))]</span><br></pre></td></tr></table></figure></p>
<h2 id="Combinations"><a href="#Combinations" class="headerlink" title="Combinations"></a><strong>Combinations</strong></h2><p>枚举C(n, k)<br>暴力DFS枚举。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return a list of lists of integers</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(self, n, k)</span>:</span></span><br><span class="line">        self.res = []</span><br><span class="line">        tmp = []</span><br><span class="line">        self.dfs(n, k, <span class="number">1</span>, <span class="number">0</span>, tmp)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, n, k, m, p, tmp)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> k == p:</span><br><span class="line">            self.res.append(tmp[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m, n+<span class="number">1</span>):</span><br><span class="line">            tmp.append(i)</span><br><span class="line">            self.dfs(n, k, i+<span class="number">1</span>, p+<span class="number">1</span>, tmp)</span><br><span class="line">            tmp.pop()</span><br></pre></td></tr></table></figure></p>
<h2 id="Minimum-Window-Substring"><a href="#Minimum-Window-Substring" class="headerlink" title="Minimum Window Substring"></a><strong>Minimum Window Substring</strong></h2><p>找出串S中最短的串，包含了串T中出现的每个字符。<br>思路是左右各一个指针，分别是pl、pr，pr先移动直到包含T中所有字符，然后pl尽量右移直到S[pl:pr]刚刚不能保证包含所有T中字符，那么S[pl-1:pr]就是一个可行的最短串。之后重复以上过程直到串尾，记下中间找到的最短段即可。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return a string</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minWindow</span><span class="params">(self, S, T)</span>:</span></span><br><span class="line">        d, dt = &#123;&#125;, dict.fromkeys(T, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> T: d[c] = d.get(c, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        pi, pj, cont = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        ans = <span class="string">""</span></span><br><span class="line">        <span class="keyword">while</span> pj &lt; len(S):</span><br><span class="line">            <span class="keyword">if</span> S[pj] <span class="keyword">in</span> dt:</span><br><span class="line">                <span class="keyword">if</span> dt[S[pj]] &lt; d[S[pj]]:</span><br><span class="line">                    cont += <span class="number">1</span></span><br><span class="line">                dt[S[pj]] += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> cont == len(T):</span><br><span class="line">                <span class="keyword">while</span> pi &lt; pj:</span><br><span class="line">                    <span class="keyword">if</span> S[pi] <span class="keyword">in</span> dt:</span><br><span class="line">                        <span class="keyword">if</span> dt[S[pi]] == d[S[pi]]:</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        dt[S[pi]] -= <span class="number">1</span>;</span><br><span class="line">                    pi+= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> ans == <span class="string">''</span> <span class="keyword">or</span> pj - pi &lt; len(ans):</span><br><span class="line">                    ans = S[pi:pj+<span class="number">1</span>]</span><br><span class="line">                dt[S[pi]] -= <span class="number">1</span></span><br><span class="line">                pi += <span class="number">1</span></span><br><span class="line">                cont -= <span class="number">1</span></span><br><span class="line">            pj += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<h2 id="Sort-Colors"><a href="#Sort-Colors" class="headerlink" title="Sort Colors"></a><strong>Sort Colors</strong></h2><p>给一个只有0，1，2的数组排序，要求only one pass。<br>貌似是USACO上的题，已经忘记当时怎么做的了。<br>一共三个指针，头指针、尾指针、”壹”指针(一开始和头指针都在开始)。从前向后，如果当前位置是1，头指针后移，而壹指针停在原地，如果是2，和尾指针指向的数交换，并且尾指针前移，如果是0，则交换0和壹指针上的数，并且头指针和壹指针都后移。<br>这里头尾指针都很容易理解，关键是对壹指针的理解，它总是在一串连续的一的开头，并且这串1的结尾就是头指针！每次头指针遇到一个0，都会将0交换到壹指针所在的位置，再将壹指针后移到下一个1。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param A a list of integers</span></span><br><span class="line">    <span class="comment"># @return nothing, sort in place</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        s, t, e = <span class="number">0</span>, <span class="number">0</span>, len(A) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> s &lt;= e:</span><br><span class="line">            <span class="keyword">if</span> A[s] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> s != t:</span><br><span class="line">                    A[s], A[t] = A[t], A[s]</span><br><span class="line">                s, t = s + <span class="number">1</span>, t + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> A[s] == <span class="number">1</span>:</span><br><span class="line">                s = s + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> A[s] == <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> s != e:</span><br><span class="line">                    A[s], A[e] = A[e], A[s]</span><br><span class="line">                e = e - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure></p>
<h2 id="Search-a-2D-Matrix"><a href="#Search-a-2D-Matrix" class="headerlink" title="Search a 2D Matrix"></a><strong>Search a 2D Matrix</strong></h2><p>把N*M个有序数按顺序排成矩阵，然后判断一个数是否在矩阵内。<br>变成矩阵难道就不是二分查找了？<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param matrix, a list of lists of integers</span></span><br><span class="line">    <span class="comment"># @param target, an integer</span></span><br><span class="line">    <span class="comment"># @return a boolean</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix, target)</span>:</span></span><br><span class="line">        l, h = <span class="number">0</span>, len(matrix) * len(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= h):</span><br><span class="line">            m = l + ((h-l) &gt;&gt; <span class="number">2</span>)</span><br><span class="line">            v =  matrix[m/len(matrix[<span class="number">0</span>])][m%len(matrix[<span class="number">0</span>])]</span><br><span class="line">            <span class="keyword">if</span> v &lt; target:</span><br><span class="line">                l = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> v &gt; target:</span><br><span class="line">                h = m - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Set-Matrix-Zeroes"><a href="#Set-Matrix-Zeroes" class="headerlink" title="Set Matrix Zeroes"></a><strong>Set Matrix Zeroes</strong></h2><p>给一个矩阵，若某格为0，该格所在行及所在列全部改为0，要求常数空间复杂度。<br>显然先扫一遍Mark的话空间复杂度是O(M+N)，这个Mark是必不可少的，不能用额外空间的话，就只能用原数组的某一行及某一列来记录了。最后再扫一遍数组，根据标记行及标记列的值来判断某格是否要置0。需要注意的是，该行及该列其它的格子要最后再置0。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param matrix, a list of lists of integers</span></span><br><span class="line">    <span class="comment"># RETURN NOTHING, MODIFY matrix IN PLACE.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setZeroes</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(matrix) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        lenn, lenm = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">        x, y = <span class="keyword">None</span>, <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(lenn):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(lenm):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] != <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                    matrix[x][j] = matrix[i][y] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    x, y = i, j</span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(lenn):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(lenm):</span><br><span class="line">                <span class="keyword">if</span> i == x <span class="keyword">or</span> j == y:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> matrix[x][j] == <span class="number">0</span> <span class="keyword">or</span> matrix[i][y] == <span class="number">0</span>:</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(lenn):</span><br><span class="line">            matrix[i][y] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(lenm):</span><br><span class="line">            matrix[x][i] = <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Edit-Distance"><a href="#Edit-Distance" class="headerlink" title="Edit Distance"></a><strong>Edit Distance</strong></h2><p>两个字符串的最短编辑距离，可以增删改。<br>经典DP，d[i][j]表示s1[1:i]和s2[1:j]的最短编辑距离，它可以由d[i-1][j]、d[i][j-1]、d[i-1][j-1]这三个状态转化而来，取最小的即可。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1, word2)</span>:</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (len(word2) + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word1) + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(word1) + <span class="number">1</span>): </span><br><span class="line">            dp[i][<span class="number">0</span>] = i</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(word2) + <span class="number">1</span>): </span><br><span class="line">            dp[<span class="number">0</span>][i] = i</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(word1) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(word2) + <span class="number">1</span>):</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                dp[i][j] = min(dp[i][j], dp[i][j - <span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">                dp[i][j] = min(dp[i][j], dp[i - <span class="number">1</span>][j] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[len(word1)][len(word2)]</span><br></pre></td></tr></table></figure></p>
<h2 id="Climbing-Stairs"><a href="#Climbing-Stairs" class="headerlink" title="Climbing Stairs"></a><strong>Climbing Stairs</strong></h2><p>爬楼梯，每次一步或两步，求爬法有多少种<br>菲波拉契数列，f[n] = f[n-1] + f[n-2]<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param n, an integer</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        f = [<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">while</span> len(f) &lt;= n:</span><br><span class="line">            f.append(f[<span class="number">-1</span>] + f[<span class="number">-2</span>])</span><br><span class="line">        <span class="keyword">return</span> f[n]</span><br></pre></td></tr></table></figure></p>
<h2 id="Sqrt-x"><a href="#Sqrt-x" class="headerlink" title="Sqrt(x)"></a><strong>Sqrt(x)</strong></h2><p>实现Sqrt(x)。<br>科普题，牛顿迭代，y = 1/2 * (y + x / y)。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param x, an integer</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sqrt</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        y0, y1 = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> int(y0) != int(y1):</span><br><span class="line">            y0 = y1</span><br><span class="line">            y1 = <span class="number">1.0</span>/<span class="number">2.0</span> * (y0 + x / y0)</span><br><span class="line">        <span class="keyword">return</span> int(y0)</span><br></pre></td></tr></table></figure></p>
<h2 id="Text-Justification"><a href="#Text-Justification" class="headerlink" title="Text Justification"></a><strong>Text Justification</strong></h2><p>数字排版，将一个字符串排列成每行N个字母。<br>恶心题，坑一堆。首先最后一行特判，单词间只有一个空格，其次关于空格均分的规则，假如8个空格3个空，就是(3,3,2)。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span><br><span class="line">words: ["This", "is", "an", "example", "of", "text", "justification."]</span><br><span class="line">L: 16.</span><br><span class="line"></span><br><span class="line">Return the formatted lines as:</span><br><span class="line">[</span><br><span class="line">   "This    is    an",</span><br><span class="line">   "example  of text",</span><br><span class="line">   "justification.  "</span><br><span class="line">]</span><br><span class="line">'''</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param words, a list of strings</span></span><br><span class="line">    <span class="comment"># @param L, an integer</span></span><br><span class="line">    <span class="comment"># @return a list of strings</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fullJustify</span><span class="params">(self, words, L)</span>:</span></span><br><span class="line">        ans, p, plen = [], <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(words)):</span><br><span class="line">            <span class="keyword">if</span> plen + len(words[i]) + i - p - <span class="number">1</span> &gt;= L:</span><br><span class="line">                spc = (L - plen) // (i - p - <span class="number">1</span>) <span class="keyword">if</span> i - p &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                sps = (L - plen - spc * (i - p - <span class="number">1</span>))</span><br><span class="line">                str = words[p]</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(p + <span class="number">1</span>, i):</span><br><span class="line">                    <span class="keyword">if</span> sps &gt; <span class="number">0</span>:</span><br><span class="line">                        str += <span class="string">' '</span></span><br><span class="line">                        sps -= <span class="number">1</span></span><br><span class="line">                    str += <span class="string">' '</span> * spc + words[j] </span><br><span class="line">                ans.append(str + <span class="string">' '</span> * (L - plen))</span><br><span class="line">                plen, p = <span class="number">0</span>, i</span><br><span class="line">            <span class="keyword">if</span> i &lt; len(words):</span><br><span class="line">                plen += len(words[i])</span><br><span class="line">        str = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> p &lt; len(words):</span><br><span class="line">            str += words[p]</span><br><span class="line">            <span class="keyword">if</span> len(str) &lt; L:</span><br><span class="line">                str += <span class="string">' '</span></span><br><span class="line">            p = p + <span class="number">1</span></span><br><span class="line">        ans.append(str + <span class="string">' '</span> * (L - len(str))) </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<h2 id="Plus-One"><a href="#Plus-One" class="headerlink" title="Plus One"></a><strong>Plus One</strong></h2><p>讲一个大数加1<br>加到不进位位置，注意头部有可能要加1<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param digits, a list of integer digits</span></span><br><span class="line">    <span class="comment"># @return a list of integer digits</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(digits)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            digits[i] = (digits[i] + <span class="number">1</span>) % <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> digits[i]:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            digits.insert(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> digits</span><br></pre></td></tr></table></figure></p>
<h2 id="Valid-Number"><a href="#Valid-Number" class="headerlink" title="Valid Number"></a><strong>Valid Number</strong></h2><p>判断一个数字是否合法<br>很麻烦的DFA，这里的合数字状况比较多，小数点前有没有数字要区别对待，WA了很多次，还参考了CSGrandeur的题解才过。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param s, a string</span></span><br><span class="line">    <span class="comment"># @return a boolean</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        s = s.strip();</span><br><span class="line">        <span class="comment"># dfa status </span></span><br><span class="line">        err = <span class="number">-1</span> <span class="comment"># error</span></span><br><span class="line">        srt = <span class="number">0</span>  <span class="comment"># start</span></span><br><span class="line">        sgd = <span class="number">1</span>  <span class="comment"># integer part sign </span></span><br><span class="line">        did = <span class="number">2</span>  <span class="comment"># integer part number</span></span><br><span class="line">        ddp = <span class="number">3</span>  <span class="comment"># xx. (there are some numbers before '.')</span></span><br><span class="line">        dnp = <span class="number">3</span>  <span class="comment"># .</span></span><br><span class="line">        dii = <span class="number">5</span>  <span class="comment"># decimal part number</span></span><br><span class="line">        exe = <span class="number">6</span>  <span class="comment"># e</span></span><br><span class="line">        sge = <span class="number">7</span>  <span class="comment"># exp part sign</span></span><br><span class="line">        die = <span class="number">8</span>  <span class="comment"># exp part number</span></span><br><span class="line">        end = <span class="number">9</span> <span class="comment"># end</span></span><br><span class="line">        <span class="comment"># construct a dfa</span></span><br><span class="line">        dfa = [[err] * <span class="number">128</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>)]</span><br><span class="line">        dfa[srt][ord(<span class="string">'+'</span>)] = dfa[srt][ord(<span class="string">'-'</span>)] = sgd</span><br><span class="line">        dfa[srt][ord(<span class="string">'.'</span>)] = dfa[sgd][ord(<span class="string">'.'</span>)] = dnp</span><br><span class="line">        dfa[did][ord(<span class="string">'.'</span>)] = ddp</span><br><span class="line">        dfa[did][ord(<span class="string">'e'</span>)] = dfa[ddp][ord(<span class="string">'e'</span>)] = dfa[dii][ord(<span class="string">'e'</span>)] = exe</span><br><span class="line">        dfa[exe][ord(<span class="string">'+'</span>)] = dfa[exe][ord(<span class="string">'-'</span>)] = sge</span><br><span class="line">        dfa[dii][<span class="number">0</span>] = dfa[ddp][<span class="number">0</span>] = dfa[did][<span class="number">0</span>] = dfa[die][<span class="number">0</span>] = end</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            t =  ord(<span class="string">'0'</span>) + i</span><br><span class="line">            dfa[srt][t] = dfa[sgd][t] = dfa[did][t] = did</span><br><span class="line">            dfa[ddp][t] = dfa[dnp][t] = dfa[dii][t] = dii</span><br><span class="line">            dfa[exe][t] = dfa[sge][t] = dfa[die][t] = die</span><br><span class="line">        <span class="comment"># run dfa with s</span></span><br><span class="line">        s = s.strip()</span><br><span class="line">        status = srt</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            status = dfa[status][ord(c)]</span><br><span class="line">            <span class="comment">#print status</span></span><br><span class="line">            <span class="keyword">if</span> (status == err):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> dfa[status][<span class="number">0</span>] == end <span class="keyword">else</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Add-Binary"><a href="#Add-Binary" class="headerlink" title="Add Binary"></a><strong>Add Binary</strong></h2><p>大数加法，只是换成了二进制而已<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param a, a string</span></span><br><span class="line">    <span class="comment"># @param b, a string</span></span><br><span class="line">    <span class="comment"># @return a string</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addBinary</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        a = [ord(c) - ord(<span class="string">'0'</span>) <span class="keyword">for</span> c <span class="keyword">in</span> a][::<span class="number">-1</span>]</span><br><span class="line">        b = [ord(c) - ord(<span class="string">'0'</span>) <span class="keyword">for</span> c <span class="keyword">in</span> b][::<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> (len(a) &lt; len(b)):</span><br><span class="line">            a, b = b, a</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">            <span class="keyword">if</span> (i &lt; len(b)):</span><br><span class="line">                a[i] += b[i]</span><br><span class="line">            a[i] += flag</span><br><span class="line">            flag = a[i] // <span class="number">2</span></span><br><span class="line">            a[i] %= <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            a.append(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join([chr(c + ord(<span class="string">'0'</span>)) <span class="keyword">for</span> c <span class="keyword">in</span> a][::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure></p>
<h2 id="Merge-Two-Sorted-Lists"><a href="#Merge-Two-Sorted-Lists" class="headerlink" title="Merge Two Sorted Lists"></a><strong>Merge Two Sorted Lists</strong></h2><p>合并两个有序列表<br>归并排序了，加个临时头节点好写一些<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param two ListNodes</span></span><br><span class="line">    <span class="comment"># @return a ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        nHead = ListNode(<span class="number">0</span>)</span><br><span class="line">        lt, rt, backHead = l1, l2, nHead</span><br><span class="line">        <span class="keyword">while</span> lt <span class="keyword">or</span> rt:</span><br><span class="line">            <span class="keyword">if</span> lt <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">                nHead.next, rt = rt, rt.next</span><br><span class="line">            <span class="keyword">elif</span> rt <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">                nHead.next, lt = lt, lt.next</span><br><span class="line">            <span class="keyword">elif</span> lt.val &lt; rt.val:</span><br><span class="line">                nHead.next, lt = lt, lt.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nHead.next, rt = rt, rt.next</span><br><span class="line">            nHead = nHead.next</span><br><span class="line">        <span class="keyword">return</span> backHead.next</span><br></pre></td></tr></table></figure></p>
<h2 id="Minimum-Path-Sum"><a href="#Minimum-Path-Sum" class="headerlink" title="Minimum Path Sum"></a><strong>Minimum Path Sum</strong></h2><p>从矩形格子的左上走到右下，经过的点和加起来最小<br>不是从上面过来就是从左边过来，DP。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param grid, a list of lists of integers</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                    grid[i][j] += grid[i][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">elif</span> j == <span class="number">0</span> <span class="keyword">and</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                    grid[i][j] += grid[i<span class="number">-1</span>][j]</span><br><span class="line">                <span class="keyword">elif</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                    grid[i][j] += min(grid[i<span class="number">-1</span>][j], grid[i][j<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> grid[len(grid) - <span class="number">1</span>][len(grid[<span class="number">0</span>]) - <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<h2 id="Unique-Paths-II"><a href="#Unique-Paths-II" class="headerlink" title="Unique Paths II"></a><strong>Unique Paths II</strong></h2><p>从矩形格子的左上走到右下，有些格子不能走，求路径数<br>只能从左边过来或者上边过来，加起来就是到这个格子的路径数，不能走的话该点就是0<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param obstacleGrid, a list of lists of integers</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid)</span>:</span></span><br><span class="line">        ans = [[<span class="number">0</span>] * len(obstacleGrid[<span class="number">0</span>]) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(obstacleGrid))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(obstacleGrid)):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>: ans[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(obstacleGrid[<span class="number">0</span>])):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][i] == <span class="number">1</span>: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>: ans[<span class="number">0</span>][i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(obstacleGrid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(obstacleGrid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    ans[i][j] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans[i][j] = ans[i][j<span class="number">-1</span>] + ans[i<span class="number">-1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> ans[len(ans)<span class="number">-1</span>][len(ans[<span class="number">0</span>])<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<h2 id="Unique-Paths"><a href="#Unique-Paths" class="headerlink" title="Unique Paths"></a><strong>Unique Paths</strong></h2><p>从矩形格子的左上走到右下，有些格子不能走，求路径数<br>比上面一题还简单了，不用考虑不能走的格子<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m, n)</span>:</span></span><br><span class="line">        g = [[<span class="number">0</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> range(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m): g[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n): g[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                g[i][j] = g[i][j<span class="number">-1</span>] + g[i<span class="number">-1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> g[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<h2 id="Rotate-List"><a href="#Rotate-List" class="headerlink" title="Rotate List"></a><strong>Rotate List</strong></h2><p>链表循环右移K个元素(即后k个元素放到链表头)<br>注意K要模N，然后走len-K步，再将前半部链表接到后面即可。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param head, a ListNode</span></span><br><span class="line">    <span class="comment"># @param k, an integer</span></span><br><span class="line">    <span class="comment"># @return a ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateRight</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        p, len = head, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p.next:</span><br><span class="line">            p, len = p.next, len + <span class="number">1</span></span><br><span class="line">        k = len - k % len</span><br><span class="line">        <span class="keyword">if</span> k == len:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        pp, len = head, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> len &lt; k:</span><br><span class="line">            pp, len = pp.next, len + <span class="number">1</span></span><br><span class="line">        p.next, head, pp.next = head, pp.next, <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></p>
<h2 id="Permutation-Sequence"><a href="#Permutation-Sequence" class="headerlink" title="Permutation Sequence"></a><strong>Permutation Sequence</strong></h2><p>对于集合[1,2..n]，给出它字典序第K大的排列<br>注意到[1,2..n]有n个排列，从第一位开始枚举没用过的数字，每枚举一个，剩下的m个位置就有m!种排序方法，K不断减去m!直到K<m!，然后继续枚举下一位。 <figure="" class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return a string</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPermutation</span><span class="params">(self, n, k)</span>:</span></span><br><span class="line">        d, ans, use = [<span class="number">0</span>, <span class="number">1</span>], [], [<span class="string">'0'</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">10</span>) : d.append( i * d[<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            ans.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> use[j] == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                ans[i] = chr(ord(<span class="string">'0'</span>) + j + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> k &lt;= d[n-i<span class="number">-1</span>]:</span><br><span class="line">                    use[j] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                k -= d[n-i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(ans)</span><br></pre></td></tr></table></m!，然后继续枚举下一位。></p>
<h2 id="Spiral-Matrix-II"><a href="#Spiral-Matrix-II" class="headerlink" title="Spiral Matrix II"></a><strong>Spiral Matrix II</strong></h2><p>将1~n^n个数以如下方式填充到矩阵中<br>一直向某个方向走，走到不能走顺时针旋转90度继续走<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line"> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ],</span><br><span class="line"> [ <span class="number">8</span>, <span class="number">9</span>, <span class="number">4</span> ],</span><br><span class="line"> [ <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span> ]</span><br><span class="line">]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return a list of lists of integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateMatrix</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        a = [[<span class="number">0</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        sx, sy = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        dx, dy, dn = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>], [<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n * n):</span><br><span class="line">            a[sx][sy] = i + <span class="number">1</span></span><br><span class="line">            nx, ny = sx + dx[dn], sy + dy[dn]</span><br><span class="line">            <span class="keyword">if</span> nx &lt; <span class="number">0</span> <span class="keyword">or</span> nx &lt; <span class="number">0</span> <span class="keyword">or</span> nx &gt;= n <span class="keyword">or</span> ny &gt;= n <span class="keyword">or</span> a[nx][ny]:</span><br><span class="line">                dn = (dn + <span class="number">1</span>) % <span class="number">4</span></span><br><span class="line">                nx, ny = sx + dx[dn], sy + dy[dn]</span><br><span class="line">            sx, sy = nx, ny</span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure></p>
<h2 id="Length-of-Last-Word"><a href="#Length-of-Last-Word" class="headerlink" title="Length of Last Word"></a><strong>Length of Last Word</strong></h2><p>求最后一个单词的长度<br>从后向前找，先找到第一个非空格，再从该位置向前找到第一个空格<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param s, a string</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLastWord</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        i = len(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> s[i] == <span class="string">' '</span>: i -= <span class="number">1</span></span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> s[j] != <span class="string">' '</span>: j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">else</span> i - j</span><br></pre></td></tr></table></figure></p>
<h2 id="Insert-Interval"><a href="#Insert-Interval" class="headerlink" title="Insert Interval"></a><strong>Insert Interval</strong></h2><p>将一个区间合并到一个连续不重叠区间集合，要求返回的区间也是连续不重叠的。<br>将和新区间有重叠的区间合并为一个大区间即可，其它区间不变。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param intervals, a list of Intervals</span></span><br><span class="line">    <span class="comment"># @param newInterval, a Interval</span></span><br><span class="line">    <span class="comment"># @return a list of Interval</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, intervals, newInterval)</span>:</span></span><br><span class="line">        ans, inserted = [], <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(intervals)):</span><br><span class="line">            <span class="keyword">if</span> intervals[i].end &lt; newInterval.start:</span><br><span class="line">                ans.append(intervals[i])</span><br><span class="line">            <span class="keyword">elif</span> intervals[i].start &gt; newInterval.end:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> inserted:</span><br><span class="line">                    inserted = <span class="keyword">True</span></span><br><span class="line">                    ans.append(newInterval)</span><br><span class="line">                ans.append(intervals[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                newInterval.start = min(newInterval.start, intervals[i].start)</span><br><span class="line">                newInterval.end = max(newInterval.end, intervals[i].end)</span><br><span class="line">        <span class="keyword">if</span> len(ans) == <span class="number">0</span> <span class="keyword">or</span> newInterval.start &gt; ans[<span class="number">-1</span>].end:</span><br><span class="line">            ans.append(newInterval)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<h2 id="Merge-Intervals"><a href="#Merge-Intervals" class="headerlink" title="Merge Intervals"></a><strong>Merge Intervals</strong></h2><p>合并若个个区间。<br>先按左端点排序，合并时直到当前区间左端点比之前所有区间最右的端点还要靠右的时候将之前的区间合并。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param intervals, a list of Interval</span></span><br><span class="line">    <span class="comment"># @return a list of Interval</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals)</span>:</span></span><br><span class="line">        intervals.sort(cmp = <span class="keyword">lambda</span> x, y: cmp(x.start, y.start) <span class="keyword">or</span> (x.start == y.start <span class="keyword">and</span> cmp(x.end,y.end)))</span><br><span class="line">        ans, p, maxr = [], <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(intervals) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> (i == len(intervals) <span class="keyword">or</span> intervals[i].start &gt; maxr):</span><br><span class="line">                ans.append(Interval(intervals[p].start, maxr))</span><br><span class="line">                p = i</span><br><span class="line">            <span class="keyword">if</span> i &lt; len(intervals):</span><br><span class="line">                maxr = max(maxr, intervals[i].end)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<h2 id="Jump-Game"><a href="#Jump-Game" class="headerlink" title="Jump Game"></a><strong>Jump Game</strong></h2><p>每个格子上的数字N表示从这个格子可以到后面的N格，问是否能从头走到尾。<br>x表示从当前位置最多还能走几步， 每走一步都将x-1和当前格子的值的较大值作为x的值。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param A, a list of integers</span></span><br><span class="line">    <span class="comment"># @return a boolean</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(A) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        maxj = A[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(A)):</span><br><span class="line">            maxj -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (maxj &lt; <span class="number">0</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            maxj = max(maxj, A[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Spiral-Matrix"><a href="#Spiral-Matrix" class="headerlink" title="Spiral Matrix"></a><strong>Spiral Matrix</strong></h2><p>和上面的<code>Spiral Matrix II</code>差不多，就是从填数变成了取数。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line"> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ],</span><br><span class="line"> [ <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ],</span><br><span class="line"> [ <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> ]</span><br><span class="line">]</span><br><span class="line"><span class="keyword">return</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param matrix, a list of lists of integers</span></span><br><span class="line">    <span class="comment"># @return a list of integers</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(matrix) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        a, ans, m, n = matrix, [], len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">        x = [[<span class="number">0</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> range(m)]</span><br><span class="line">        sx, sy = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        dx, dy, dn = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>], [<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m * n):</span><br><span class="line">            ans.append(a[sx][sy])</span><br><span class="line">            x[sx][sy] = <span class="number">1</span></span><br><span class="line">            nx, ny = sx + dx[dn], sy + dy[dn]</span><br><span class="line">            <span class="keyword">if</span> nx &lt; <span class="number">0</span> <span class="keyword">or</span> nx &lt; <span class="number">0</span> <span class="keyword">or</span> nx &gt;= m <span class="keyword">or</span> ny &gt;= n <span class="keyword">or</span> x[nx][ny]:</span><br><span class="line">                dn = (dn + <span class="number">1</span>) % <span class="number">4</span></span><br><span class="line">                nx, ny = sx + dx[dn], sy + dy[dn]</span><br><span class="line">            sx, sy = nx, ny</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<h2 id="Maximum-Subarray"><a href="#Maximum-Subarray" class="headerlink" title="Maximum Subarray"></a><strong>Maximum Subarray</strong></h2><p>求子区间最大值<br>前缀和加到负数就重新累加，因为前面的数加进来只会减小总和。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param A, a list of integers</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        ans, sum = A[<span class="number">0</span>], A[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(A)):</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; <span class="number">0</span>):</span><br><span class="line">                sum = A[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                sum += A[i]</span><br><span class="line">            ans = max(ans, sum)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<h2 id="N-Queens-II"><a href="#N-Queens-II" class="headerlink" title="N-Queens II"></a><strong>N-Queens II</strong></h2><p>八(N)皇后问题求解数<br>位压缩DFS<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">totalNQueens</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.ans = <span class="number">0</span></span><br><span class="line">        self.full = ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>)</span><br><span class="line">        self.dfs(n, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, n, p, lt, rt, nt)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == p:</span><br><span class="line">            self.ans += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        can = (~(lt | rt | nt) &amp; self.full)</span><br><span class="line">        <span class="keyword">while</span> can:</span><br><span class="line">           now = can&amp;-can</span><br><span class="line">           self.dfs(n, p+<span class="number">1</span>, (lt|now)&gt;&gt;<span class="number">1</span>, (rt|now)&lt;&lt;<span class="number">1</span>, nt|now)</span><br><span class="line">           can -= now</span><br></pre></td></tr></table></figure></p>
<h2 id="N-Queens"><a href="#N-Queens" class="headerlink" title="N-Queens"></a><strong>N-Queens</strong></h2><p>还是N皇后问题，只是要给出具体解<br>一样是未压缩DFS，py的字符串和list总要转来转去真是不怎么方便。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return a list of lists of string</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.ans, self.dt = [], &#123;&#125;</span><br><span class="line">        self.full = ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n): self.dt[<span class="number">1</span>&lt;&lt;i] = i</span><br><span class="line">        tmp = [[<span class="string">'.'</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        self.dfs(n, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, tmp)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, n, p, lt, rt, nt, tmp)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == p:</span><br><span class="line">            self.ans.append([<span class="string">''</span>.join(s) <span class="keyword">for</span> s <span class="keyword">in</span> tmp])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        can = (~(lt | rt | nt) &amp; self.full)</span><br><span class="line">        <span class="keyword">while</span> can:</span><br><span class="line">           now = can&amp;-can</span><br><span class="line">           tmp[p][self.dt[now]] = <span class="string">'Q'</span></span><br><span class="line">           self.dfs(n, p+<span class="number">1</span>, (lt|now)&gt;&gt;<span class="number">1</span>, (rt|now)&lt;&lt;<span class="number">1</span>, nt|now, tmp)</span><br><span class="line">           tmp[p][self.dt[now]] = <span class="string">'.'</span></span><br><span class="line">           can -= now</span><br></pre></td></tr></table></figure></p>
<h2 id="Pow-x-n"><a href="#Pow-x-n" class="headerlink" title="Pow(x, n)"></a><strong>Pow(x, n)</strong></h2><p>快速幂，二分<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param x, a float</span></span><br><span class="line">    <span class="comment"># @param n, a integer</span></span><br><span class="line">    <span class="comment"># @return a float</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pow</span><span class="params">(self, x, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        xx = pow(x, n &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        xx *= xx</span><br><span class="line">        <span class="keyword">if</span> n &amp; <span class="number">1</span>: xx *= x</span><br><span class="line">        <span class="keyword">return</span> xx</span><br></pre></td></tr></table></figure></p>
<h2 id="Anagrams"><a href="#Anagrams" class="headerlink" title="Anagrams"></a><strong>Anagrams</strong></h2><p>真不知道题目这单词是什么意思。。其实就是列表里如果有多个单词由相同字母组成就加到结果里，比如cat,tac。<br>排序后map一下就OK了，注意处理重复问题，Map中添加新元素时记录该元素的下标，遇到<code>Anagrams</code>后将对应单词加进结果集并将下标改为-1，下次就不再添加该单词。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param strs, a list of strings</span></span><br><span class="line">    <span class="comment"># @return a list of strings</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">anagrams</span><span class="params">(self, strs)</span>:</span></span><br><span class="line">        ans, dt = [], &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(strs)):</span><br><span class="line">            lt = list(strs[i])</span><br><span class="line">            lt.sort()</span><br><span class="line">            s = <span class="string">''</span>.join(lt)</span><br><span class="line">            d = dt.get(s, <span class="number">-2</span>)</span><br><span class="line">            <span class="keyword">if</span> d == <span class="number">-2</span>:</span><br><span class="line">                dt[s] = i</span><br><span class="line">            <span class="keyword">elif</span> d == <span class="number">-1</span>:</span><br><span class="line">                ans.append(strs[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans.append(strs[i])</span><br><span class="line">                ans.append(strs[d])</span><br><span class="line">                dt[s] = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<h2 id="Rotate-Image"><a href="#Rotate-Image" class="headerlink" title="Rotate Image"></a><strong>Rotate Image</strong></h2><p>将一个二维数组90度旋转，要求原地工作。<br>数学学的差，半天才把源坐标和目的坐标的对应关系算出来。四个一组进行旋转。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param matrix, a list of lists of integers</span></span><br><span class="line">    <span class="comment"># @return a list of lists of integers</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        L = len(matrix)</span><br><span class="line">        R = (L + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, R):</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">0</span>, L - R):</span><br><span class="line">                <span class="comment">#(x,y)-&gt;(y,l-1-x)-&gt;(l-1-x,l-1-y)-&gt;(l-1-y,x)</span></span><br><span class="line">                matrix[x][y], matrix[y][L<span class="number">-1</span>-x], matrix[L<span class="number">-1</span>-x][L<span class="number">-1</span>-y], matrix[L<span class="number">-1</span>-y][x] \</span><br><span class="line">                = matrix[L<span class="number">-1</span>-y][x], matrix[x][y], matrix[y][L<span class="number">-1</span>-x], matrix[L<span class="number">-1</span>-x][L<span class="number">-1</span>-y]</span><br><span class="line">        <span class="keyword">return</span> matrix</span><br></pre></td></tr></table></figure></p>
<h2 id="Permutations-II"><a href="#Permutations-II" class="headerlink" title="Permutations II"></a><strong>Permutations II</strong></h2><h2 id="Permutations"><a href="#Permutations" class="headerlink" title="Permutations"></a><strong>Permutations</strong></h2><p>这两题一样，都是给出一个集合，得到它的所有排列。只是一个有重复，一个没重复。按下面这种解法有没有重复都是一样的。<br>这里实现了一下STL里的next_permutation函数，用于得到当前排列的下一个排列（按字典序）。<br>next_permutation先从后向前找到第一个d[i]<d[i+1]的数，之后再从后向前找第一个d[j]>d[i]的数，最后swap(d[i],d[j])并且reverse(d[i+1…n])就得到了下一个排列。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param num, a list of integer</span></span><br><span class="line">    <span class="comment"># @return a list of lists of integers</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        num.sort()</span><br><span class="line">        ans = [num[:]]</span><br><span class="line">        <span class="keyword">while</span> self.next_permutation(num):</span><br><span class="line">            ans.append(num[:])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next_permutation</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(num)<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> num[i] &lt; num[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(num)<span class="number">-1</span>, i, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> num[j] &gt; num[i]:</span><br><span class="line">                num[i], num[j] = num[j], num[i]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, (len(num) - i)//<span class="number">2</span>):</span><br><span class="line">            num[i+j+<span class="number">1</span>], num[len(num)-j<span class="number">-1</span>] = num[len(num)-j<span class="number">-1</span>], num[i+j+<span class="number">1</span>] </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></d[i+1]的数，之后再从后向前找第一个d[j]></p>
<h2 id="Jump-Game-II"><a href="#Jump-Game-II" class="headerlink" title="Jump Game II"></a><strong>Jump Game II</strong></h2><p>每个格子上的数字N表示从这个格子可以跳到后面的1~N格，问从头到尾至少要跳几步。<br>一边遍历一边记录从前面的格子最远能够跳到的格子，假设前一步最远可以跳到第x格，那么遍历到第x格的时候，下一步的最远距离也已经知道了。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param A, a list of integers</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        maxj, maxn, tms = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A) - <span class="number">1</span>):</span><br><span class="line">            maxn = max(maxn, A[i] + i)</span><br><span class="line">            <span class="keyword">if</span> i == maxj:</span><br><span class="line">                maxj, tms = maxn, tms + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> tms</span><br></pre></td></tr></table></figure></p>
<h2 id="Wildcard-Matching"><a href="#Wildcard-Matching" class="headerlink" title="Wildcard Matching"></a><strong>Wildcard Matching</strong></h2><p>实现带<code>?</code>和<code>*</code>的模糊匹配，其中<code>?</code>匹配单字符，<code>*</code>匹配任意长度字符串<br>先写了个DP，超时了，模式串和匹配串都有可能非常长。对于这题的数据，搜索还快一些，对于<em>号使用非贪婪匹配，优先匹配尽量少的字符。记录最后一次匹配到的</em>时p和s扫描到的位置，失配时回溯（其实就是枚举*匹配的长度）。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param s, an input string</span></span><br><span class="line">    <span class="comment"># @param p, a pattern string</span></span><br><span class="line">    <span class="comment"># @return a boolean</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        ps, pp, lastp, lasts = <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> ps &lt; len(s):</span><br><span class="line">            <span class="keyword">if</span> pp &lt; len(p) <span class="keyword">and</span> (s[ps] == p[pp] <span class="keyword">or</span> p[pp] == <span class="string">'?'</span>):</span><br><span class="line">                ps, pp = ps + <span class="number">1</span>, pp + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> pp &lt; len(p) <span class="keyword">and</span> p[pp] == <span class="string">'*'</span>:</span><br><span class="line">                pp = pp + <span class="number">1</span></span><br><span class="line">                lastp, lasts = pp, ps</span><br><span class="line">            <span class="keyword">elif</span> lastp != <span class="number">-1</span>:</span><br><span class="line">                lasts = lasts + <span class="number">1</span></span><br><span class="line">                pp, ps = lastp, lasts</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">while</span> pp &lt; len(p) <span class="keyword">and</span> p[pp] == <span class="string">'*'</span>:</span><br><span class="line">            pp = pp + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ps == len(s) <span class="keyword">and</span> pp == len(p)</span><br></pre></td></tr></table></figure></p>
<h2 id="Multiply-Strings"><a href="#Multiply-Strings" class="headerlink" title="Multiply Strings"></a><strong>Multiply Strings</strong></h2><p>字符串模拟大数乘法<br>虽然py支持大数，但还是手写一下吧，再次觉得py处理字符串转来转去的不方便，也许是我太菜了吧。。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param num1, a string</span></span><br><span class="line">    <span class="comment"># @param num2, a string</span></span><br><span class="line">    <span class="comment"># @return a string</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, num1, num2)</span>:</span></span><br><span class="line">        num1 = [ord(i) - ord(<span class="string">'0'</span>) <span class="keyword">for</span> i <span class="keyword">in</span> num1][::<span class="number">-1</span>]</span><br><span class="line">        num2 = [ord(i) - ord(<span class="string">'0'</span>) <span class="keyword">for</span> i <span class="keyword">in</span> num2][::<span class="number">-1</span>]</span><br><span class="line">        ans = [<span class="number">0</span>] * (len(num1) + len(num2) + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(num1)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(num2)):</span><br><span class="line">                ans[i + j] += num1[i] * num2[j]</span><br><span class="line">                ans[i + j + <span class="number">1</span>] += ans[i + j]</span><br><span class="line">                <span class="comment">#ans[i + j]</span></span><br><span class="line">        <span class="keyword">while</span> len(ans) &gt; <span class="number">1</span> <span class="keyword">and</span> ans[len(ans) - <span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">            ans.pop()</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join([chr(i + ord(<span class="string">'0'</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> ans][::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure></p>
<h2 id="Trapping-Rain-Water"><a href="#Trapping-Rain-Water" class="headerlink" title="Trapping Rain Water"></a><strong>Trapping Rain Water</strong></h2><p>每个木板有高度，求最多能蓄多少水<br>分别求出每块木板左边最高的和右边最高的，然后取较小的就是该块木板的最高蓄水位。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param A, a list of integers</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        maxl, maxr, maxv, ans = [], [], <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            <span class="keyword">if</span> A[i] &gt; maxv: maxv = A[i]</span><br><span class="line">            maxl.append(maxv)</span><br><span class="line">        maxv = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> A[i] &gt; maxv: maxv = A[i]</span><br><span class="line">            maxr.append(maxv)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            minh = min(maxl[i], maxr[len(A) - i - <span class="number">1</span>]) - A[i]</span><br><span class="line">            ans += minh <span class="keyword">if</span> minh &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<h2 id="First-Missing-Positive"><a href="#First-Missing-Positive" class="headerlink" title="First Missing Positive"></a><strong>First Missing Positive</strong></h2><p>找第一个少了的正数。<br>如果1~N都有，N正好就是数组长度，所以用原数组做Hash就可以了，Hash的范围是1~N。具体实现是不断swap当前数和它应该在的位置上的数，直到当前数不能换了为止（每个数最多只会帮换一次，所以复杂度还是O(N)）。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param A, a list of integers</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        L = len(A)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(L):</span><br><span class="line">            <span class="keyword">while</span> A[i] &gt; <span class="number">0</span> <span class="keyword">and</span> A[i] &lt;= L <span class="keyword">and</span> A[i] != A[A[i] - <span class="number">1</span>] <span class="keyword">and</span> i != A[i] - <span class="number">1</span>:</span><br><span class="line">                A[A[i] - <span class="number">1</span>], A[i] = A[i], A[A[i] - <span class="number">1</span>]</span><br><span class="line">                <span class="comment">#A[i], A[A[i] - 1] = A[A[i] - 1], A[i]  dosen't work</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(L):</span><br><span class="line">            <span class="keyword">if</span> i != A[i] - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> L + <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Combination-Sum-II"><a href="#Combination-Sum-II" class="headerlink" title="Combination Sum II"></a><strong>Combination Sum II</strong></h2><p>在集合中选几个数和为N，每个数只能用一次，问有多少种解法。<br>这种有重复数字需要避免重复解的DFS，处理方法基本都一样，就是DFS的时候如果前一个数是相同的并且没用，那么这个数也不能用。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param candidates, a list of integers</span></span><br><span class="line">    <span class="comment"># @param target, integer</span></span><br><span class="line">    <span class="comment"># @return a list of lists of integers</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span><span class="params">(self, candidates, target)</span>:</span></span><br><span class="line">        candidates.sort()</span><br><span class="line">        self.ans, tmp, use = [], [], [<span class="number">0</span>] * len(candidates)</span><br><span class="line">        self.dfs(candidates, target, <span class="number">0</span>, <span class="number">0</span>, tmp, use)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, can, target, p, now, tmp, use)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> now == target:</span><br><span class="line">            self.ans.append(tmp[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(p, len(can)):</span><br><span class="line">            <span class="keyword">if</span> now + can[i] &lt;= target <span class="keyword">and</span> (i == <span class="number">0</span> <span class="keyword">or</span> can[i] != can[i<span class="number">-1</span>] <span class="keyword">or</span> use[i<span class="number">-1</span>] == <span class="number">1</span>):</span><br><span class="line">                tmp.append(can[i]);</span><br><span class="line">                use[i] = <span class="number">1</span></span><br><span class="line">                self.dfs(can, target, i+<span class="number">1</span>, now + can[i], tmp, use)</span><br><span class="line">                tmp.pop()</span><br><span class="line">                use[i] = <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Combination-Sum"><a href="#Combination-Sum" class="headerlink" title="Combination Sum"></a><strong>Combination Sum</strong></h2><p>上一题的简化版，而且每个数可以用多次，直接DFS就可以了<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param candidates, a list of integers</span></span><br><span class="line">    <span class="comment"># @param target, integer</span></span><br><span class="line">    <span class="comment"># @return a list of lists of integers</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates, target)</span>:</span></span><br><span class="line">        candidates.sort()</span><br><span class="line">        self.ans, tmp = [], []</span><br><span class="line">        self.dfs(candidates, target, <span class="number">0</span>, <span class="number">0</span>, tmp)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, candidates, target, p, now, tmp)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> now == target:</span><br><span class="line">            self.ans.append(tmp[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(p, len(candidates)):</span><br><span class="line">            <span class="keyword">if</span> now + candidates[i] &lt;= target:</span><br><span class="line">                tmp.append(candidates[i])</span><br><span class="line">                self.dfs(candidates, target, i, now+candidates[i], tmp)</span><br><span class="line">                tmp.pop()</span><br></pre></td></tr></table></figure></p>
<h2 id="Count-and-Say"><a href="#Count-and-Say" class="headerlink" title="Count and Say"></a><strong>Count and Say</strong></h2><p>求以下序列的第N项，模拟即可。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>, <span class="number">11</span>, <span class="number">21</span>, <span class="number">1211</span>, <span class="number">111221</span>, ...</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">is</span> read off <span class="keyword">as</span> <span class="string">"one 1"</span> <span class="keyword">or</span> <span class="number">11.</span></span><br><span class="line"><span class="number">11</span> <span class="keyword">is</span> read off <span class="keyword">as</span> <span class="string">"two 1s"</span> <span class="keyword">or</span> <span class="number">21.</span></span><br><span class="line"><span class="number">21</span> <span class="keyword">is</span> read off <span class="keyword">as</span> <span class="string">"one 2, then one 1"</span> <span class="keyword">or</span> <span class="number">1211.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return a string</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        s, now = [str(<span class="number">1</span>), <span class="string">''</span>], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            now, pre, tot = now^<span class="number">1</span>, now, <span class="number">0</span></span><br><span class="line">            s[now], p = <span class="string">""</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> p  &lt; len(s[pre]):</span><br><span class="line">                tot, v, p = <span class="number">1</span>, s[pre][p], p + <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> p &lt; len(s[pre]) <span class="keyword">and</span> v == s[pre][p]:</span><br><span class="line">                    p += <span class="number">1</span></span><br><span class="line">                    tot += <span class="number">1</span></span><br><span class="line">                s[now] += str(tot) +  v</span><br><span class="line">        <span class="keyword">return</span> s[now]</span><br></pre></td></tr></table></figure></p>
<h2 id="Sudoku-Solver"><a href="#Sudoku-Solver" class="headerlink" title="Sudoku Solver"></a><strong>Sudoku Solver</strong></h2><p>求数独的解，dancing links不会，只能写个位压缩版了。。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param board, a 9x9 2D array</span></span><br><span class="line">    <span class="comment"># Solve the Sudoku by modifying the input board in-place.</span></span><br><span class="line">    <span class="comment"># Do not return any value.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveSudoku</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        lt, rt, bt = [<span class="number">0</span>] * <span class="number">9</span>, [<span class="number">0</span>] * <span class="number">9</span>, [<span class="number">0</span>] * <span class="number">9</span></span><br><span class="line">        self.dt = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>): self.dt[<span class="number">1</span>&lt;&lt;i] = chr(ord(<span class="string">'1'</span>)+i)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            board[i] = list(board[i])</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'.'</span>):</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                num = ord(board[i][j]) - ord(<span class="string">'1'</span>)</span><br><span class="line">                lt[i] |= <span class="number">1</span> &lt;&lt; num</span><br><span class="line">                rt[j] |= <span class="number">1</span> &lt;&lt; num</span><br><span class="line">                bt[j//<span class="number">3</span>*<span class="number">3</span>+i//<span class="number">3</span>] |= <span class="number">1</span> &lt;&lt; num</span><br><span class="line">        self.dfs(board, <span class="number">0</span>, lt, rt, bt)</span><br><span class="line">        board = [<span class="string">''</span>.join(s) <span class="keyword">for</span> s <span class="keyword">in</span> board]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, board, p, lt, rt, bt)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> p &lt; <span class="number">81</span> <span class="keyword">and</span> board[p/<span class="number">9</span>][p%<span class="number">9</span>] != <span class="string">'.'</span>:</span><br><span class="line">            p += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> p == <span class="number">81</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        i, j, k = p//<span class="number">9</span>, p%<span class="number">9</span>, p%<span class="number">9</span>//<span class="number">3</span>*<span class="number">3</span>+p//<span class="number">9</span>//<span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span> board[i][j] != <span class="string">'.'</span>:</span><br><span class="line">            self.dfs(board, p + <span class="number">1</span>, lt, rt, bt)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        can = (~(lt[i]|rt[j]|bt[k])) &amp; (<span class="number">0x1ff</span>)</span><br><span class="line">        pre = board[i]</span><br><span class="line">        <span class="keyword">while</span> can:</span><br><span class="line">            num = can&amp;-can</span><br><span class="line">            board[i][j] = self.dt[num]</span><br><span class="line">            lt[i] |= num</span><br><span class="line">            rt[j] |= num</span><br><span class="line">            bt[k] |= num</span><br><span class="line">            <span class="keyword">if</span> self.dfs(board, p + <span class="number">1</span>, lt, rt , bt):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            board[i][j] = <span class="string">'.'</span></span><br><span class="line">            lt[i] &amp;= ~num</span><br><span class="line">            rt[j] &amp;= ~num</span><br><span class="line">            bt[k] &amp;= ~num</span><br><span class="line">            can -= num</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Valid-Sudoku"><a href="#Valid-Sudoku" class="headerlink" title="Valid Sudoku"></a><strong>Valid Sudoku</strong></h2><p>判断数独初始局面是否合法，就是在上题初始化的过程中加上了判断。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param board, a 9x9 2D array</span></span><br><span class="line">    <span class="comment"># @return a boolean</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        lt, rt, bt = [<span class="number">0</span>] * <span class="number">9</span>, [<span class="number">0</span>] * <span class="number">9</span>, [<span class="number">0</span>] * <span class="number">9</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">                <span class="keyword">print</span> i, j</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'.'</span>):</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                num = ord(board[i][j]) - ord(<span class="string">'1'</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> == (~(lt[i]|rt[j]|bt[j/<span class="number">3</span>*<span class="number">3</span>+i/<span class="number">3</span>]) &amp; (<span class="number">1</span>&lt;&lt;num)):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                lt[i] |= <span class="number">1</span> &lt;&lt; num</span><br><span class="line">                rt[j] |= <span class="number">1</span> &lt;&lt; num</span><br><span class="line">                bt[j/<span class="number">3</span>*<span class="number">3</span>+i/<span class="number">3</span>] |= <span class="number">1</span> &lt;&lt; num</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Search-Insert-Position"><a href="#Search-Insert-Position" class="headerlink" title="Search Insert Position"></a><strong>Search Insert Position</strong></h2><p>给一个排序数组和一个数，找出这个数应该插在哪个位置。<br>二分稍加变形，保证l最后停在第一个比它大的数的位置上。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param A, a list of integers</span></span><br><span class="line">    <span class="comment"># @param target, an integer to be inserted</span></span><br><span class="line">    <span class="comment"># @return integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, A, target)</span>:</span></span><br><span class="line">        l, h = <span class="number">0</span>, len(A) </span><br><span class="line">        <span class="keyword">while</span> l &lt; h:</span><br><span class="line">            m = (l + h) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> A[m] &lt; target:</span><br><span class="line">                l = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                h = m</span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure></p>
<h2 id="Search-for-a-Range"><a href="#Search-for-a-Range" class="headerlink" title="Search for a Range"></a><strong>Search for a Range</strong></h2><p>找出排序数组中一个数第一次出现的位置和最后一次出现的位置。<br>也是二分变形，写对真不容易。。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param A, a list of integers</span></span><br><span class="line">    <span class="comment"># @param target, an integer to be searched</span></span><br><span class="line">    <span class="comment"># @return a list of length 2, [index1, index2]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, A, target)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> [self.lower_bound(A, target), self.upper_bound(A, target)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span><span class="params">(self, A, target)</span>:</span></span><br><span class="line">        l, h, m = <span class="number">0</span>, len(A), <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; h:</span><br><span class="line">            m = (l + h) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> A[m] &lt; target:</span><br><span class="line">                l = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                h = m</span><br><span class="line">        <span class="keyword">return</span> l <span class="keyword">if</span> l &lt; len(A) <span class="keyword">and</span> A[l] == target <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">upper_bound</span><span class="params">(self, A, target)</span>:</span></span><br><span class="line">        l, h, m = <span class="number">0</span>, len(A),  <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; h:</span><br><span class="line">            m = (l + h) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> A[m] &lt;= target:</span><br><span class="line">                l = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                h = m</span><br><span class="line">        <span class="keyword">return</span> l<span class="number">-1</span> <span class="keyword">if</span> l<span class="number">-1</span> &lt; len(A) <span class="keyword">and</span> A[l<span class="number">-1</span>] == target <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Search-in-Rotated-Sorted-Array"><a href="#Search-in-Rotated-Sorted-Array" class="headerlink" title="Search in Rotated Sorted Array"></a><strong>Search in Rotated Sorted Array</strong></h2><p>把一个有序数组循环右移若干位之后，查找某个数是否在这个数组中。<br>还是二分，只是到底是向左还是向右的时候判断要复杂一些。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param A, a list of integers</span></span><br><span class="line">    <span class="comment"># @param target, an integer to be searched</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, A, target)</span>:</span></span><br><span class="line">        l, h = <span class="number">0</span>, len(A) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= h):</span><br><span class="line">            m = l + ((h - l) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> A[m] == target:</span><br><span class="line">                <span class="keyword">return</span> m</span><br><span class="line">            <span class="keyword">elif</span> (A[m] &gt; A[l] <span class="keyword">and</span> target &lt; A[m] <span class="keyword">and</span> target &gt;= A[l]) <span class="keyword">or</span> (A[m] &lt; A[l] <span class="keyword">and</span> <span class="keyword">not</span> (target &lt;= A[h] <span class="keyword">and</span> target &gt; A[m])):</span><br><span class="line">                h = m - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = m + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Longest-Valid-Parentheses"><a href="#Longest-Valid-Parentheses" class="headerlink" title="Longest Valid Parentheses"></a><strong>Longest Valid Parentheses</strong></h2><p>最长的合法括号序列。<br>写了好久，首先用栈可以找到每个右括号对应的左括号，如果它对应的左括号前面也是一个独立的合法括号序列，要累加起来。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param s, a string</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        stk, p ,ans = [], [<span class="number">0</span>] * len(s), <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">'('</span>:</span><br><span class="line">                stk.append(i)</span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">')'</span>:</span><br><span class="line">                <span class="keyword">if</span> len(stk) &gt; <span class="number">0</span>:</span><br><span class="line">                    p[i] = i - stk[<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> i &gt;= p[i] <span class="keyword">and</span> p[i - p[i]]:</span><br><span class="line">                        p[i] += p[i-p[i]]</span><br><span class="line">                    ans = max(ans, p[i])</span><br><span class="line">                    stk.pop()</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<h2 id="Next-Permutation"><a href="#Next-Permutation" class="headerlink" title="Next Permutation"></a><strong>Next Permutation</strong></h2><p>求下一个序列，前面的<code>Permutations</code>题中已经用到了。(CTRL+F向上找。。)<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param num, a list of integer</span></span><br><span class="line">    <span class="comment"># @return a list of integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(num)<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> num[i] &lt; num[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            num.reverse()</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(num)<span class="number">-1</span>, i, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> num[j] &gt; num[i]:</span><br><span class="line">                num[i], num[j] = num[j], num[i]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, (len(num) - i)//<span class="number">2</span>):</span><br><span class="line">            num[i+j+<span class="number">1</span>], num[len(num)-j<span class="number">-1</span>] = num[len(num)-j<span class="number">-1</span>], num[i+j+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure></p>
<h2 id="Substring-with-Concatenation-of-All-Words"><a href="#Substring-with-Concatenation-of-All-Words" class="headerlink" title="Substring with Concatenation of All Words"></a><strong>Substring with Concatenation of All Words</strong></h2><p>给出一个字符串集合L和字符串S，找出S从哪些位置开始恰好包含每个字符串各一次。<br>这类判断某一段包含了哪些内容的题做法都差不多，一个pre指针，一个last指针，用一个集合记录这之间出现的值，last指针不断往后扫直到扫到多余的元素，然后pre指针再从之前的位置扫到第一个有这个元素的位置之后，这时候last指针就可以继续后移了。<br>这个题就是要做一些变形，将S分成len(L(0))段，每段分别使用以上算法。比如len(L(0))=3,len(S)=10时，就分成S[0,3,6,9],S[1,4,7],S[2,5,8]三段。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param S, a string</span></span><br><span class="line">    <span class="comment"># @param L, a list of string</span></span><br><span class="line">    <span class="comment"># @return a list of integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSubstring</span><span class="params">(self, S, L)</span>:</span></span><br><span class="line">        LS, LL, LL0 = len(S), len(L), len(L[<span class="number">0</span>])</span><br><span class="line">        did, ids, dl = &#123;&#125;, <span class="number">0</span>, &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> L: </span><br><span class="line">            id = did.get(s, <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span> id == <span class="number">-1</span>:</span><br><span class="line">                 ids = ids + <span class="number">1</span></span><br><span class="line">                 id = ids</span><br><span class="line">                 did[s] = id</span><br><span class="line">            dl[id] = dl.get(id, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        pos, ans = [<span class="number">0</span>] * LS, []</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> did.items():</span><br><span class="line">            f = S.find(k)</span><br><span class="line">            <span class="keyword">while</span> f != <span class="number">-1</span>:</span><br><span class="line">                pos[f] = v</span><br><span class="line">                f = S.find(k, f + <span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">for</span> sp <span class="keyword">in</span> range(LL0):</span><br><span class="line">            np, pp, tot, dt = sp, sp, <span class="number">0</span>, &#123;&#125;</span><br><span class="line">            <span class="keyword">while</span> np &lt; LS:</span><br><span class="line">                t = pos[np]</span><br><span class="line">                <span class="keyword">if</span> t == <span class="number">0</span>:</span><br><span class="line">                    tot, dt = <span class="number">0</span>, &#123;&#125;</span><br><span class="line">                    pp, np = np + LL0, np + LL0</span><br><span class="line">                <span class="keyword">elif</span> dt.get(t, <span class="number">0</span>) &lt; dl[t]:</span><br><span class="line">                    dt[t] = dt.get(t, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">                    tot = tot + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> tot == LL:</span><br><span class="line">                        ans.append(pp)</span><br><span class="line">                    np = np + LL0</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">while</span> pos[pp] != t:</span><br><span class="line">                        tot = tot - <span class="number">1</span></span><br><span class="line">                        dt[pos[pp]] -= <span class="number">1</span></span><br><span class="line">                        pp = pp + LL0</span><br><span class="line">                    pp = pp + LL0</span><br><span class="line">                    dt[t] -= <span class="number">1</span></span><br><span class="line">                    tot = tot - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<h2 id="Divide-Two-Integers"><a href="#Divide-Two-Integers" class="headerlink" title="Divide Two Integers"></a><strong>Divide Two Integers</strong></h2><p>不使用乘除法实现加法。<br>二进制思想，用二进制去凑答案。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(self, dividend, divisor)</span>:</span></span><br><span class="line">        flag, ans = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> dividend &lt; <span class="number">0</span>:</span><br><span class="line">            flag, dividend = flag^<span class="number">1</span>, -dividend</span><br><span class="line">        <span class="keyword">if</span> divisor &lt; <span class="number">0</span>:</span><br><span class="line">            flag, divisor = flag^<span class="number">1</span>, -divisor</span><br><span class="line">        <span class="keyword">while</span> dividend &gt;= divisor:</span><br><span class="line">            count, newDivisor = <span class="number">1</span>, divisor</span><br><span class="line">            <span class="keyword">while</span> newDivisor + newDivisor &lt;= dividend:</span><br><span class="line">                newDivisor = newDivisor + newDivisor</span><br><span class="line">                count = count + count</span><br><span class="line">            dividend -= newDivisor</span><br><span class="line">            ans += count</span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> flag == <span class="number">0</span> <span class="keyword">else</span> -ans</span><br></pre></td></tr></table></figure></p>
<h2 id="Implement-strStr"><a href="#Implement-strStr" class="headerlink" title="Implement strStr()"></a><strong>Implement strStr()</strong></h2><p>实现strStr()函数<br>KMP了，好久不写真的写不出来了。。。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param haystack, a string</span></span><br><span class="line">    <span class="comment"># @param needle, a string</span></span><br><span class="line">    <span class="comment"># @return a string or None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack, needle)</span>:</span></span><br><span class="line">        lenh, lenn = len(haystack), len(needle)</span><br><span class="line">        <span class="keyword">if</span> lenn == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> haystack</span><br><span class="line">        next, p = [<span class="number">-1</span>] * (lenn), <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, lenn):</span><br><span class="line">            <span class="keyword">while</span> p &gt;= <span class="number">0</span> <span class="keyword">and</span> needle[i] != needle[p + <span class="number">1</span>]:</span><br><span class="line">                p = next[p]</span><br><span class="line">            <span class="keyword">if</span> needle[i] == needle[p + <span class="number">1</span>]:</span><br><span class="line">                p  = p + <span class="number">1</span></span><br><span class="line">            next[i] = p</span><br><span class="line">        p = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(lenh):</span><br><span class="line">            <span class="keyword">while</span> p &gt;= <span class="number">0</span> <span class="keyword">and</span> haystack[i] != needle[p + <span class="number">1</span>]:</span><br><span class="line">                p = next[p]</span><br><span class="line">            <span class="keyword">if</span> haystack[i] == needle[p + <span class="number">1</span>]:</span><br><span class="line">                p = p + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> p + <span class="number">1</span> == lenn:</span><br><span class="line">                <span class="keyword">return</span> haystack[i - p:] </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Remove-Element"><a href="#Remove-Element" class="headerlink" title="Remove Element"></a><strong>Remove Element</strong></h2><p>在数组中移除指定元素<br>不是指定的元素就往前面放就行了<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param    A       a list of integers</span></span><br><span class="line">    <span class="comment"># @param    elem    an integer, value need to be removed</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, A, elem)</span>:</span></span><br><span class="line">        sz = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</span><br><span class="line">            <span class="keyword">if</span> A[i] != elem:</span><br><span class="line">                A[sz] = A[i]</span><br><span class="line">                sz += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> sz</span><br></pre></td></tr></table></figure></p>
<h2 id="Remove-Duplicates-from-Sorted-Array"><a href="#Remove-Duplicates-from-Sorted-Array" class="headerlink" title="Remove Duplicates from Sorted Array"></a><strong>Remove Duplicates from Sorted Array</strong></h2><p>有序数组删除重复元素到只留一个<br>往数组前部放，放之前保证和已放的最后一个不一样即可<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param a list of integers</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(A) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        sz = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(A)):</span><br><span class="line">            <span class="keyword">if</span> A[i] != A[i<span class="number">-1</span>]:</span><br><span class="line">                A[sz] = A[i]</span><br><span class="line">                sz += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> sz</span><br></pre></td></tr></table></figure></p>
<h2 id="Reverse-Nodes-in-k-Group"><a href="#Reverse-Nodes-in-k-Group" class="headerlink" title="Reverse Nodes in k-Group"></a><strong>Reverse Nodes in k-Group</strong></h2><p>链表，每K个一段进行reverse。<br>到每第K个元素的时候掉个头就行，中间就是正常的链表逆置，注意最后几个不要处理。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param head, a ListNode</span></span><br><span class="line">    <span class="comment"># @param k, an integer</span></span><br><span class="line">    <span class="comment"># @return a ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        nHead = ListNode(<span class="number">0</span>)</span><br><span class="line">        nHead.next = head</span><br><span class="line">        p2, lenl = head, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p2: p2, lenl = p2.next, lenl + <span class="number">1</span></span><br><span class="line">        now, pre, ind = head, nHead, <span class="number">1</span></span><br><span class="line">        preHead, preHeadNext = nHead, head</span><br><span class="line">        <span class="keyword">while</span> now:</span><br><span class="line">            <span class="keyword">if</span> lenl - ind &lt; lenl % k:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            next = now.next</span><br><span class="line">            now.next = pre</span><br><span class="line">            <span class="keyword">if</span> ind % k == <span class="number">0</span>:</span><br><span class="line">                preHead.next = now</span><br><span class="line">                preHeadNext.next = next</span><br><span class="line">                preHead = preHeadNext</span><br><span class="line">                pre = preHead</span><br><span class="line">                preHeadNext = next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = now</span><br><span class="line">            now, ind = next, ind + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nHead.next</span><br></pre></td></tr></table></figure></p>
<h2 id="Swap-Nodes-in-Pairs"><a href="#Swap-Nodes-in-Pairs" class="headerlink" title="Swap Nodes in Pairs"></a><strong>Swap Nodes in Pairs</strong></h2><p>上一题的简化版，相当于 K=2<br>代码写的相当暴力，反正两个元素最多也就3个NEXT就能访问到下一段。。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param a ListNode</span></span><br><span class="line">    <span class="comment"># @return a ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> head.next <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        nHead = ListNode(<span class="number">0</span>)</span><br><span class="line">        nHead.next = head</span><br><span class="line">        p1, p2 = nHead, head</span><br><span class="line">        <span class="keyword">while</span> p2 <span class="keyword">and</span> p2.next:</span><br><span class="line">            p2 = p2.next.next</span><br><span class="line">            p1.next.next.next = p1.next</span><br><span class="line">            p1.next = p1.next.next</span><br><span class="line">            p1.next.next.next = p2</span><br><span class="line">            p1 = p1.next.next</span><br><span class="line">        <span class="keyword">return</span> nHead.next</span><br></pre></td></tr></table></figure></p>
<h2 id="Merge-k-Sorted-Lists"><a href="#Merge-k-Sorted-Lists" class="headerlink" title="Merge k Sorted Lists"></a><strong>Merge k Sorted Lists</strong></h2><p>合并K个有序链表。<br>和归并一样，每次选K个链表头部最小的元素。这里的优化就是用一个堆来维护这K个元素的最小值，复杂度<code>O(sum(len(Ki)) * logK)</code><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param a list of ListNode</span></span><br><span class="line">    <span class="comment"># @return a ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists)</span>:</span></span><br><span class="line">        self.heap = [[i, lists[i].val] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(lists)) <span class="keyword">if</span> lists[i] != <span class="keyword">None</span>]</span><br><span class="line">        self.hsize = len(self.heap)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.hsize - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            self.adjustdown(i)</span><br><span class="line">            </span><br><span class="line">        nHead = ListNode(<span class="number">0</span>)</span><br><span class="line">        head = nHead</span><br><span class="line">        <span class="keyword">while</span> self.hsize &gt; <span class="number">0</span>:</span><br><span class="line">            ind, val = self.heap[<span class="number">0</span>][<span class="number">0</span>], self.heap[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">            head.next = lists[ind]</span><br><span class="line">            head = head.next</span><br><span class="line">            lists[ind] = lists[ind].next</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> lists[ind] <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">                self.heap[<span class="number">0</span>] = self.heap[self.hsize<span class="number">-1</span>]</span><br><span class="line">                self.hsize = self.hsize - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.heap[<span class="number">0</span>] = [ind, lists[ind].val]</span><br><span class="line">            self.adjustdown(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> nHead.next</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">adjustdown</span><span class="params">(self, p)</span>:</span></span><br><span class="line">        lc = <span class="keyword">lambda</span> x: (x + <span class="number">1</span>) * <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">        rc = <span class="keyword">lambda</span> x: (x + <span class="number">1</span>) * <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            np, pv = p, self.heap[p][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> lc(p) &lt; self.hsize <span class="keyword">and</span> self.heap[lc(p)][<span class="number">1</span>] &lt; pv:</span><br><span class="line">                np, pv = lc(p), self.heap[lc(p)][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> rc(p) &lt; self.hsize <span class="keyword">and</span> self.heap[rc(p)][<span class="number">1</span>] &lt; pv:</span><br><span class="line">                np = rc(p)</span><br><span class="line">            <span class="keyword">if</span> np == p:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.heap[np], self.heap[p] = self.heap[p], self.heap[np]</span><br><span class="line">                p = np</span><br></pre></td></tr></table></figure></p>
<h2 id="Generate-Parentheses"><a href="#Generate-Parentheses" class="headerlink" title="Generate Parentheses"></a><strong>Generate Parentheses</strong></h2><p>生成所有可能的括号序列<br>DFS搜索了，注意右括号不能比左括号多即可<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param an integer</span></span><br><span class="line">    <span class="comment"># @return a list of string</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.ans, tmp = [], []</span><br><span class="line">        lb = <span class="number">0</span></span><br><span class="line">        self.dfs(lb, <span class="number">0</span>, n, tmp)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, lb, p, n, tmp)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> p == n * <span class="number">2</span>:</span><br><span class="line">            self.ans.append(<span class="string">''</span>.join(tmp))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> lb &lt; n:</span><br><span class="line">            tmp.append(<span class="string">'('</span>)</span><br><span class="line">            self.dfs(lb + <span class="number">1</span>, p + <span class="number">1</span>, n, tmp)</span><br><span class="line">            tmp.pop()</span><br><span class="line">        <span class="keyword">if</span> p - lb &lt; lb:</span><br><span class="line">            tmp.append(<span class="string">')'</span>)</span><br><span class="line">            self.dfs(lb, p + <span class="number">1</span>, n, tmp)</span><br><span class="line">            tmp.pop()</span><br></pre></td></tr></table></figure></p>
<h2 id="Valid-Parentheses"><a href="#Valid-Parentheses" class="headerlink" title="Valid Parentheses"></a><strong>Valid Parentheses</strong></h2><p>判断括号序列是否合法，共有三种括号<br>用栈，遇到右括号时左括号必须和当前括号是一对，然后出栈<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return a boolean</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        dct = &#123;<span class="string">'('</span>:<span class="string">')'</span>, <span class="string">'['</span>:<span class="string">']'</span>, <span class="string">'&#123;'</span>:<span class="string">'&#125;'</span>&#125;</span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> dct.get(c, <span class="keyword">None</span>):</span><br><span class="line">                stk.append(c)</span><br><span class="line">            <span class="keyword">elif</span> len(stk) == <span class="number">0</span> <span class="keyword">or</span> dct[stk[<span class="number">-1</span>]] != c:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stk.pop()</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> len(stk) == <span class="number">0</span> <span class="keyword">else</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Remove-Nth-Node-From-End-of-List"><a href="#Remove-Nth-Node-From-End-of-List" class="headerlink" title="Remove Nth Node From End of List"></a><strong>Remove Nth Node From End of List</strong></h2><p>删除链表的第N个元素，只能扫一遍<br>一个指针先走N-K步，然后另一个指针在开头，一起走直到先走的指针到达末尾，删除后走的指针<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return a ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head, n)</span>:</span></span><br><span class="line">        nHead = ListNode(<span class="number">0</span>)</span><br><span class="line">        nHead.next = head</span><br><span class="line">        p, t = <span class="number">0</span>, head</span><br><span class="line">        <span class="keyword">while</span> p &lt; n:</span><br><span class="line">            t = t.next</span><br><span class="line">            p += <span class="number">1</span></span><br><span class="line">        pre = nHead</span><br><span class="line">        <span class="keyword">while</span> t:</span><br><span class="line">            t, pre = t.next, pre.next</span><br><span class="line">        pre.next = pre.next.next</span><br><span class="line">        <span class="keyword">return</span> nHead.next</span><br></pre></td></tr></table></figure></p>
<h2 id="Letter-Combinations-of-a-Phone-Number"><a href="#Letter-Combinations-of-a-Phone-Number" class="headerlink" title="Letter Combinations of a Phone Number"></a><strong>Letter Combinations of a Phone Number</strong></h2><p>按一串电话按键，求所有可能的字母组合<br>DFS<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return a list of strings, [s1, s2]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(digits) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="string">""</span>]</span><br><span class="line">        self.dglist = [<span class="string">""</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>]</span><br><span class="line">        self.ans, tmp = [], []</span><br><span class="line">        self.dfs(digits, <span class="number">0</span>, tmp)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, digits, p, tmp)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> (p == len(digits)):</span><br><span class="line">            self.ans.append(<span class="string">''</span>.join(tmp))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> self.dglist[ord(digits[p]) - ord(<span class="string">'0'</span>)]:</span><br><span class="line">            tmp.append(c)</span><br><span class="line">            self.dfs(digits, p + <span class="number">1</span>, tmp)</span><br><span class="line">            tmp.pop()</span><br></pre></td></tr></table></figure></p>
<h2 id="4Sum"><a href="#4Sum" class="headerlink" title="4Sum"></a><strong>4Sum</strong></h2><p>求集合中4个数的和为0的所有解。<br>做法和3sum一样，py超时，用c++写的，复杂度O(N^3)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; fourSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line">        sort(num.begin(), num.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; num[i] == num[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; num.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; num[j] == num[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> l = j + <span class="number">1</span>, r = num.size() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = num[i] + num[j] + num[l] + num[r];</span><br><span class="line">                    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                        ans.push_back(&#123;num[i], num[j], num[l], num[r]&#125;);</span><br><span class="line">                        <span class="keyword">while</span> (l &lt; r &amp;&amp; num[l] == num[l + <span class="number">1</span>]) l++; l++;</span><br><span class="line">                        <span class="keyword">while</span> (l &lt; r &amp;&amp; num[r] == num[r - <span class="number">1</span>]) r--; r--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                        l++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        r--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="3Sum-Closest"><a href="#3Sum-Closest" class="headerlink" title="3Sum Closest"></a><strong>3Sum Closest</strong></h2><p>求集合中3个数能够得到的距离target最近的和<br>和3Sum一样，而且不用处理重复解问题了。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, num, target)</span>:</span></span><br><span class="line">        num.sort()</span><br><span class="line">        ans = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(num)):</span><br><span class="line">            l, r = i + <span class="number">1</span>, len(num) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt; r):                    </span><br><span class="line">                sum = num[l] + num[r] + num[i]</span><br><span class="line">                <span class="keyword">if</span> ans <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> abs(sum- target) &lt; abs(ans - target):</span><br><span class="line">                    ans = sum</span><br><span class="line">                <span class="keyword">if</span> sum &lt;= target:</span><br><span class="line">                    l = l + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = r - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<h2 id="3Sum"><a href="#3Sum" class="headerlink" title="3Sum"></a><strong>3Sum</strong></h2><p>求3个数的和为target的所有解。<br>枚举第一个数，然后第二个数为这个数的后一个数，第三个数为最后一个数，如果和小于0，第二个数后移，如大于0第三个数前移，等于0的话记录结果并且都向中间移。<strong>注意处理重复解</strong>。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return a list of lists of length 3, [[val1,val2,val3]]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        num.sort()</span><br><span class="line">        dct, ans = &#123;&#125;, []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(num)):</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> <span class="keyword">and</span> num[i] == num[i<span class="number">-1</span>]):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            l, r = i + <span class="number">1</span>, len(num) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                sum = num[l] + num[r] + num[i]</span><br><span class="line">                <span class="keyword">if</span> sum == <span class="number">0</span>:</span><br><span class="line">                    ans.append([num[i], num[l], num[r]])</span><br><span class="line">                    <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> num[l] == num[l + <span class="number">1</span>]: l = l + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> num[r] == num[r - <span class="number">1</span>]: r = r - <span class="number">1</span></span><br><span class="line">                    l, r = l + <span class="number">1</span>, r - <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> sum &lt; <span class="number">0</span>:</span><br><span class="line">                    l = l + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = r - <span class="number">1</span>   </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<h2 id="Longest-Common-Prefix"><a href="#Longest-Common-Prefix" class="headerlink" title="Longest Common Prefix"></a><strong>Longest Common Prefix</strong></h2><p>求所有的字符串的最长公共前缀<br>暴力直接一位位扫，直到遇到某位有不同的字符或者某个字符串结尾<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return a string</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(strs) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> strs[<span class="number">0</span>] <span class="keyword">if</span> len(strs) == <span class="number">1</span> <span class="keyword">else</span> <span class="string">""</span></span><br><span class="line">        end, minl = <span class="number">0</span>, min([len(s) <span class="keyword">for</span> s <span class="keyword">in</span> strs])</span><br><span class="line">        <span class="keyword">while</span> end &lt; minl:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(strs)):</span><br><span class="line">                <span class="keyword">if</span> strs[i][end] != strs[i<span class="number">-1</span>][end]:</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>][:end]</span><br><span class="line">            end = end + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>][:end]</span><br></pre></td></tr></table></figure></p>
<h2 id="Roman-to-Integer"><a href="#Roman-to-Integer" class="headerlink" title="Roman to Integer"></a><strong>Roman to Integer</strong></h2><p>罗马数字转阿拉伯数字。<br>右边比左边大就减对应值，否则就加对应值。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        roval = &#123;<span class="string">'I'</span>:<span class="number">1</span>, <span class="string">'V'</span>:<span class="number">5</span>, <span class="string">'X'</span>:<span class="number">10</span>, <span class="string">'L'</span>:<span class="number">50</span>, <span class="string">'C'</span>:<span class="number">100</span>, <span class="string">'D'</span>:<span class="number">500</span>, <span class="string">'M'</span>:<span class="number">1000</span>&#125;</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> i + <span class="number">1</span> &lt; len(s) <span class="keyword">and</span> roval[s[i]] &lt; roval[s[i+<span class="number">1</span>]]:</span><br><span class="line">                ans -= roval[s[i]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans += roval[s[i]]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<h2 id="Integer-to-Roman"><a href="#Integer-to-Roman" class="headerlink" title="Integer to Roman"></a><strong>Integer to Roman</strong></h2><p>阿拉伯数字转罗马数字。<br>打表。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return a string</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        ronum  = [[<span class="string">''</span>, <span class="string">'I'</span>, <span class="string">'II'</span>, <span class="string">'III'</span>, <span class="string">'IV'</span>, <span class="string">'V'</span>, <span class="string">'VI'</span>, <span class="string">'VII'</span>, <span class="string">'VIII'</span>, <span class="string">'IX'</span>],</span><br><span class="line">                  [<span class="string">''</span>, <span class="string">'X'</span>, <span class="string">'XX'</span>, <span class="string">'XXX'</span>, <span class="string">'XL'</span>, <span class="string">'L'</span>, <span class="string">'LX'</span>, <span class="string">'LXX'</span>, <span class="string">'LXXX'</span>, <span class="string">'XC'</span>],</span><br><span class="line">                  [<span class="string">''</span>, <span class="string">'C'</span>, <span class="string">'CC'</span>, <span class="string">'CCC'</span>, <span class="string">'CD'</span>, <span class="string">'D'</span>, <span class="string">'DC'</span>, <span class="string">'DCC'</span>, <span class="string">'DCCC'</span>, <span class="string">'CM'</span>],</span><br><span class="line">                  [<span class="string">''</span>, <span class="string">'M'</span>, <span class="string">'MM'</span>, <span class="string">'MMM'</span>, <span class="string">'  '</span>, <span class="string">' '</span>, <span class="string">'  '</span>, <span class="string">'   '</span>, <span class="string">'    '</span>, <span class="string">'  '</span>]]</span><br><span class="line">        ans, ind = <span class="string">''</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> num:</span><br><span class="line">            ans = ronum[ind][num%<span class="number">10</span>] + ans</span><br><span class="line">            num, ind = num / <span class="number">10</span>, ind + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<h2 id="Container-With-Most-Water"><a href="#Container-With-Most-Water" class="headerlink" title="Container With Most Water"></a><strong>Container With Most Water</strong></h2><p>给出N个高度不同的挡板y,每个柱子距离1，找出两个挡板，使这两个挡板之间盛水最多<br>一开始题目理解错了，以为挡板都先放好了，其实是选两个挡板出来，其它挡板不用。。<br>从两边向中间枚举，假设两块挡板满足height[x]<height[y]，那么把y向中间移动肯定得不到更优的解，所以每次选较矮的一块往中间移 <figure="" class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height)</span>:</span></span><br><span class="line">        l, r, ans = <span class="number">0</span>, len(height) - <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            ans = max(ans, (r - l) * min(height[r], height[l]))</span><br><span class="line">            <span class="keyword">if</span> height[l] &lt; height[r]:</span><br><span class="line">                l = l + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = r - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></height[y]，那么把y向中间移动肯定得不到更优的解，所以每次选较矮的一块往中间移></p>
<h2 id="Regular-Expression-Matching"><a href="#Regular-Expression-Matching" class="headerlink" title="Regular Expression Matching"></a><strong>Regular Expression Matching</strong></h2><p>实现带<code>.</code>和<code>*</code>的正则表达式匹配，其中<code>.</code>匹配任一字符，<code>*</code>表示重复之前内容0次以上。<br>DP做的，dp[i][j]表示s[1..i]和p[1..j]匹配，需要考虑的情况还是比较复杂的，搜索应该也可行。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return a boolean</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        s, p = <span class="string">' '</span> + s, <span class="string">' '</span> + p</span><br><span class="line">        dp = [[<span class="keyword">False</span>] * (len(p)) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s))]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">        ind = <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> ind &lt; len(p) <span class="keyword">and</span> p[ind] == <span class="string">'*'</span>:</span><br><span class="line">            dp[<span class="number">0</span>][ind], ind = <span class="keyword">True</span>, ind + <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(p)):</span><br><span class="line">                <span class="keyword">if</span> (s[i] == p[j] <span class="keyword">or</span> p[j] == <span class="string">'.'</span>) <span class="keyword">and</span> dp[i<span class="number">-1</span>][j<span class="number">-1</span>]:</span><br><span class="line">                    dp[i][j] = <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">if</span> p[j] == <span class="string">'*'</span> <span class="keyword">and</span> (dp[i][j<span class="number">-2</span>] <span class="keyword">or</span> ((p[j<span class="number">-1</span>] == <span class="string">'.'</span> <span class="keyword">or</span> p[j<span class="number">-1</span>] == s[i]) <span class="keyword">and</span> (dp[i<span class="number">-1</span>][j<span class="number">-2</span>] <span class="keyword">or</span> dp[i<span class="number">-1</span>][j]))):</span><br><span class="line">                    dp[i][j] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> dp[len(s) - <span class="number">1</span>][len(p) - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line"><span class="keyword">print</span> s.isMatch(<span class="string">"aa"</span>, <span class="string">"a"</span>)              <span class="comment"># False</span></span><br><span class="line"><span class="keyword">print</span> s.isMatch(<span class="string">"aa"</span>, <span class="string">"aa"</span>)             <span class="comment"># True</span></span><br><span class="line"><span class="keyword">print</span> s.isMatch(<span class="string">"aaa"</span>,<span class="string">"aa"</span>)             <span class="comment"># False</span></span><br><span class="line"><span class="keyword">print</span> s.isMatch(<span class="string">"aa"</span>, <span class="string">"a*"</span>)             <span class="comment"># True</span></span><br><span class="line"><span class="keyword">print</span> s.isMatch(<span class="string">"aa"</span>, <span class="string">".*"</span>)             <span class="comment"># True</span></span><br><span class="line"><span class="keyword">print</span> s.isMatch(<span class="string">"ab"</span>, <span class="string">".*"</span>)             <span class="comment"># True</span></span><br><span class="line"><span class="keyword">print</span> s.isMatch(<span class="string">"aab"</span>, <span class="string">"c*a*b"</span>)         <span class="comment"># True</span></span><br><span class="line"><span class="keyword">print</span> s.isMatch(<span class="string">"aaa"</span>, <span class="string">"ab*a"</span>)          <span class="comment"># Fasle</span></span><br><span class="line"><span class="keyword">print</span> s.isMatch(<span class="string">"aaba"</span>, <span class="string">"ab*a*c*a"</span>)     <span class="comment"># False</span></span><br><span class="line"><span class="keyword">print</span> s.isMatch(<span class="string">""</span>, <span class="string">".*"</span>)               <span class="comment"># True</span></span><br><span class="line"><span class="keyword">print</span> s.isMatch(<span class="string">"bbab"</span>, <span class="string">"b*a*"</span>)         <span class="comment"># False</span></span><br><span class="line"><span class="keyword">print</span> s.isMatch(<span class="string">"aab"</span>, <span class="string">"b.*"</span>)           <span class="comment"># False</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Palindrome-Number"><a href="#Palindrome-Number" class="headerlink" title="Palindrome Number"></a><strong>Palindrome Number</strong></h2><p>判断一个数字是否是回文串<br>判断翻转后的数字和原数字是否相同即可。虽然翻转后可能溢出。。但是。。这种东西py没有。。<br>一开始还写了个数组存，其实不需要，一开始使a=x，然后不断b=b*10+a%10，b就是a翻转的结果了<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return a boolean</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span> <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">else</span> <span class="keyword">True</span></span><br><span class="line">        a, b = x, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> a:</span><br><span class="line">            b, a = b * <span class="number">10</span> + a % <span class="number">10</span>, a / <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> b == x</span><br></pre></td></tr></table></figure></p>
<h2 id="String-to-Integer-atoi"><a href="#String-to-Integer-atoi" class="headerlink" title="String to Integer (atoi)"></a><strong>String to Integer (atoi)</strong></h2><p>实现atoi<br>坑略多，主要是以下几个：<br>1.前面有空格；<br>2.遇到非法字符就不再分析后面的；<br>3.有可能越界。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">atoi</span><span class="params">(self, str)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(str) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        sgn, num, p = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        imin, imax = <span class="number">-1</span>&lt;&lt;<span class="number">31</span>, (<span class="number">1</span>&lt;&lt;<span class="number">31</span>)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> str[p] == <span class="string">' '</span>:</span><br><span class="line">            p  = p + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> str[p] == <span class="string">'-'</span> <span class="keyword">or</span> str[p] == <span class="string">'+'</span>:</span><br><span class="line">            sgn = <span class="number">1</span> <span class="keyword">if</span> str[p] == <span class="string">'-'</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            p = p + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p &lt; len(str) <span class="keyword">and</span> str[p] &gt;= <span class="string">'0'</span> <span class="keyword">and</span> str[p] &lt;= <span class="string">'9'</span>:</span><br><span class="line">            num = num * <span class="number">10</span> + ord(str[p]) - ord(<span class="string">'0'</span>)</span><br><span class="line">            x = -num <span class="keyword">if</span> sgn <span class="keyword">else</span> num</span><br><span class="line">            <span class="keyword">if</span> x &lt; imin: <span class="keyword">return</span> imin</span><br><span class="line">            <span class="keyword">if</span> x &gt; imax: <span class="keyword">return</span> imax</span><br><span class="line">            p = p + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -num <span class="keyword">if</span> sgn <span class="keyword">else</span> num</span><br></pre></td></tr></table></figure></p>
<h2 id="Reverse-Integer"><a href="#Reverse-Integer" class="headerlink" title="Reverse Integer"></a><strong>Reverse Integer</strong></h2><p>翻转一个数字<br>注意可能会溢出，py就不用管了，但是c的话记得用long long<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        a = <span class="number">0</span></span><br><span class="line">        b = x <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">else</span> -x</span><br><span class="line">        <span class="keyword">while</span> b:</span><br><span class="line">            a, b = a * <span class="number">10</span> + b % <span class="number">10</span>, b / <span class="number">10</span> </span><br><span class="line">        <span class="keyword">return</span> a <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">else</span> -a</span><br></pre></td></tr></table></figure></p>
<h2 id="ZigZag-Conversion"><a href="#ZigZag-Conversion" class="headerlink" title="ZigZag Conversion"></a><strong>ZigZag Conversion</strong></h2><p>将一个字符串的字符Z形排列，然后按行顺序输出所有字母，下面有样例<br>找到规律，然后模拟<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span><br><span class="line">P   A   H   N   1   5   ...</span><br><span class="line">A P L S I I G   2 4 6 8 ...</span><br><span class="line">Y   I   R       3   7   ...</span><br><span class="line">convert("PAYPALISHIRING", 3) should return "PAHNAPLSIIGYIR".</span><br><span class="line">'''</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return a string</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(self, s, nRows)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> nRows == <span class="number">1</span> <span class="keyword">or</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        res, lens = [], len(s)</span><br><span class="line">        add, now = [nRows * <span class="number">2</span> - <span class="number">2</span>, <span class="number">0</span>], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(nRows):</span><br><span class="line">            <span class="keyword">if</span> i &lt; lens:</span><br><span class="line">                res.append(i)</span><br><span class="line">            <span class="keyword">while</span> res[<span class="number">-1</span>] + add[now] &lt; lens:</span><br><span class="line">                <span class="keyword">if</span> add[now] &gt; <span class="number">0</span>:</span><br><span class="line">                    res.append(res[<span class="number">-1</span>] + add[now])</span><br><span class="line">                now ^= <span class="number">1</span></span><br><span class="line">            add, now = [add[<span class="number">0</span>] - <span class="number">2</span>, add[<span class="number">1</span>] + <span class="number">2</span>], <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join([s[i] <span class="keyword">for</span> i <span class="keyword">in</span> res])</span><br><span class="line"></span><br><span class="line">s = Solution()</span><br><span class="line"><span class="keyword">print</span> s.convert(<span class="string">"A"</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="Longest-Palindromic-Substring"><a href="#Longest-Palindromic-Substring" class="headerlink" title="Longest Palindromic Substring"></a><strong>Longest Palindromic Substring</strong></h2><p>求最大回文子串长度<br>这个O(n)算法看了不亚于三遍了，每次写都会忘。。可能是因为没理解透彻，然后也没怎么用吧。<br>核心思想就是利用了回文串的对称性质。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return a string</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        arr = [<span class="string">'$'</span>, <span class="string">'#'</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            arr.append(s[i])</span><br><span class="line">            arr.append(<span class="string">'#'</span>)</span><br><span class="line">        p = [<span class="number">0</span>] * len(arr)</span><br><span class="line">        mx, pos, ansp = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(arr)):</span><br><span class="line">            p[i] = min(mx - i, p[<span class="number">2</span> * pos - i]) <span class="keyword">if</span> mx &gt; i <span class="keyword">else</span> <span class="number">1</span> </span><br><span class="line">            <span class="keyword">while</span> p[i] + i &lt; len(arr) <span class="keyword">and</span> arr[i + p[i]] == arr[i - p[i]]: </span><br><span class="line">                p[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> p[i] + i &gt; mx:</span><br><span class="line">                mx, pos = p[i] + i, i</span><br><span class="line">            <span class="keyword">if</span> p[i] &gt; p[ansp]:</span><br><span class="line">                ansp = i</span><br><span class="line">        st = (ansp - p[ansp] + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> s[st:st + p[ansp] - <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<h2 id="Add-Two-Numbers"><a href="#Add-Two-Numbers" class="headerlink" title="Add Two Numbers"></a><strong>Add Two Numbers</strong></h2><p>链表版大数加法<br>和数组没什么区别吧。。？翻转都不用了。。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return a ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        nHead, flag = ListNode(<span class="number">0</span>), <span class="number">0</span></span><br><span class="line">        head = nHead</span><br><span class="line">        <span class="keyword">while</span> flag <span class="keyword">or</span> l1 <span class="keyword">or</span> l2:</span><br><span class="line">            node = ListNode(flag)</span><br><span class="line">            <span class="keyword">if</span> l1: </span><br><span class="line">                node.val += l1.val</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">if</span> l2: </span><br><span class="line">                node.val += l2.val</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            flag = node.val // <span class="number">10</span></span><br><span class="line">            node.val %= <span class="number">10</span></span><br><span class="line">            head.next, head = node, node</span><br><span class="line">        <span class="keyword">return</span> nHead.next</span><br></pre></td></tr></table></figure></p>
<h2 id="Longest-Substring-Without-Repeating-Characters"><a href="#Longest-Substring-Without-Repeating-Characters" class="headerlink" title="Longest Substring Without Repeating Characters"></a><strong>Longest Substring Without Repeating Characters</strong></h2><p>求最长的没有重复字符的子串<br>维护两个指针，保证两个指针之间的串没有重复字符，后指针扫到某个字符重复时就将前指针向后移到第一个和当前字符相同的字符之后<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        dict, ans, p1, p2 = &#123;&#125;, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p2 &lt; len(s):</span><br><span class="line">            p = dict.get(s[p2], <span class="keyword">None</span>)</span><br><span class="line">            <span class="keyword">if</span> p == <span class="keyword">None</span>:</span><br><span class="line">                dict[s[p2]] = p2</span><br><span class="line">                p2 += <span class="number">1</span></span><br><span class="line">                ans = max(ans, p2 - p1)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> p1 &lt;= p:</span><br><span class="line">                    dict.pop(s[p1])</span><br><span class="line">                    p1 += <span class="number">1</span></span><br><span class="line">                p1 = p + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<h2 id="Median-of-Two-Sorted-Arrays"><a href="#Median-of-Two-Sorted-Arrays" class="headerlink" title="Median of Two Sorted Arrays"></a><strong>Median of Two Sorted Arrays</strong></h2><p>求两个有序数组的中位数。<br>我是用求两个有序数组的第K大数方法做的，复杂度没有细算。<br>假设A数组中取第x个数，Y数组取第y个数，并且满足<code>x+y=K</code>，若A[x] &lt; B[y]，则比A[x]小的数必然小于K个，也就是说A[1]~A[x]都比第K小的数要小，可以舍弃掉然后求第K-x小的数；若A[x] &gt; B[y]也是一样的道理。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return a float</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        totlen = len(A) + len(B)</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> &amp; totlen):</span><br><span class="line">            <span class="keyword">return</span> self.findK(A, B, (totlen + <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (self.findK(A, B, totlen / <span class="number">2</span>) + self.findK(A, B, totlen / <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2.0</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findK</span><span class="params">(self, A, B, K)</span>:</span></span><br><span class="line">        la, lb, pa, pb = len(A), len(B), min(K/<span class="number">2</span>, len(A)), K - min(K/<span class="number">2</span>, len(A))</span><br><span class="line">        <span class="keyword">if</span> (la &gt; lb):</span><br><span class="line">            <span class="keyword">return</span> self.findK(B, A, K)</span><br><span class="line">        <span class="keyword">if</span> (la == <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> B[K<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> (K == <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> min(A[<span class="number">0</span>], B[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> A[pa - <span class="number">1</span>] &lt; B[pb - <span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> self.findK(A[pa:], B, K - pa)</span><br><span class="line">        <span class="keyword">elif</span> A[pa - <span class="number">1</span>] &gt; B[pb - <span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> self.findK(A, B[pb:], K- pb)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> A[pa - <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<h2 id="Two-Sum"><a href="#Two-Sum" class="headerlink" title="Two Sum"></a><strong>Two Sum</strong></h2><p>找出数组中的两个数，这两个数和为target<br>扫到x时看前面Hash的数里有没有target-x，然后将x也放进Hash表。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return a tuple, (index1, index2)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, num, target)</span>:</span></span><br><span class="line">        dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(num)):</span><br><span class="line">            <span class="keyword">if</span> dict.get(target-num[i], <span class="keyword">None</span>) == <span class="keyword">None</span>:</span><br><span class="line">                dict[num[i]] = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> (dict[target-num[i]] + <span class="number">1</span>, i + <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/blog/2014/03/20/leetcode-solution-02/">LeetCode题解整理版(二)</a></p>
        <p><span>文章作者:</span><a href="/" title="访问 Vimer Su 的个人博客">Vimer Su</a></p>
        <p><span>发布时间:</span>2014年03月20日 - 13时49分</p>
        <p><span>最后更新:</span>2016年06月04日 - 22时57分</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/blog/2014/03/20/leetcode-solution-02/" title="LeetCode题解整理版(二)">http://vimersu.win/blog/2014/03/20/leetcode-solution-02/</a>
            <span class="copy-path" data-clipboard-text="原文: http://vimersu.win/blog/2014/03/20/leetcode-solution-02/　　作者: Vimer Su" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script src="/js/clipboard.min.js"></script>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target = "_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



<nav id="article-nav">
  
    <a href="/blog/2014/03/23/python-regular/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          python正则表达式
        
      </div>
    </a>
  
  
    <a href="/blog/2014/03/18/leetcode-solution-01/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">LeetCode题解整理版(一) </div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Reverse-Words-in-a-String"><span class="toc-number">1.</span> <span class="toc-text">Reverse Words in a String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Recover-Binary-Search-Tree"><span class="toc-number">2.</span> <span class="toc-text">Recover Binary Search Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Validate-Binary-Search-Tree"><span class="toc-number">3.</span> <span class="toc-text">Validate Binary Search Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Interleaving-String"><span class="toc-number">4.</span> <span class="toc-text">Interleaving String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unique-Binary-Search-Trees-II"><span class="toc-number">5.</span> <span class="toc-text">Unique Binary Search Trees II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reverse-Linked-List-II"><span class="toc-number">6.</span> <span class="toc-text">Reverse Linked List II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Subsets-II"><span class="toc-number">7.</span> <span class="toc-text">Subsets II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Decode-Ways"><span class="toc-number">8.</span> <span class="toc-text">Decode Ways</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GrayCode"><span class="toc-number">9.</span> <span class="toc-text">GrayCode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Merge-Sorted-Array"><span class="toc-number">10.</span> <span class="toc-text">Merge Sorted Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Scramble-String"><span class="toc-number">11.</span> <span class="toc-text">Scramble String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Partition-List"><span class="toc-number">12.</span> <span class="toc-text">Partition List</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Maximal-Rectangle"><span class="toc-number">13.</span> <span class="toc-text">Maximal Rectangle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Largest-Rectangle-in-Histogram"><span class="toc-number">14.</span> <span class="toc-text">Largest Rectangle in Histogram</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Remove-Duplicates-from-Sorted-List-II"><span class="toc-number">15.</span> <span class="toc-text">Remove Duplicates from Sorted List II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Remove-Duplicates-from-Sorted-List"><span class="toc-number">16.</span> <span class="toc-text">Remove Duplicates from Sorted List</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Search-in-Rotated-Sorted-Array-II"><span class="toc-number">17.</span> <span class="toc-text">Search in Rotated Sorted Array II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Remove-Duplicates-from-Sorted-Array-II"><span class="toc-number">18.</span> <span class="toc-text">Remove Duplicates from Sorted Array II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Word-Search"><span class="toc-number">19.</span> <span class="toc-text">Word Search</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Subsets"><span class="toc-number">20.</span> <span class="toc-text">Subsets</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Combinations"><span class="toc-number">21.</span> <span class="toc-text">Combinations</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Minimum-Window-Substring"><span class="toc-number">22.</span> <span class="toc-text">Minimum Window Substring</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sort-Colors"><span class="toc-number">23.</span> <span class="toc-text">Sort Colors</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Search-a-2D-Matrix"><span class="toc-number">24.</span> <span class="toc-text">Search a 2D Matrix</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set-Matrix-Zeroes"><span class="toc-number">25.</span> <span class="toc-text">Set Matrix Zeroes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Edit-Distance"><span class="toc-number">26.</span> <span class="toc-text">Edit Distance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Climbing-Stairs"><span class="toc-number">27.</span> <span class="toc-text">Climbing Stairs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sqrt-x"><span class="toc-number">28.</span> <span class="toc-text">Sqrt(x)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Text-Justification"><span class="toc-number">29.</span> <span class="toc-text">Text Justification</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Plus-One"><span class="toc-number">30.</span> <span class="toc-text">Plus One</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Valid-Number"><span class="toc-number">31.</span> <span class="toc-text">Valid Number</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Add-Binary"><span class="toc-number">32.</span> <span class="toc-text">Add Binary</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Merge-Two-Sorted-Lists"><span class="toc-number">33.</span> <span class="toc-text">Merge Two Sorted Lists</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Minimum-Path-Sum"><span class="toc-number">34.</span> <span class="toc-text">Minimum Path Sum</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unique-Paths-II"><span class="toc-number">35.</span> <span class="toc-text">Unique Paths II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unique-Paths"><span class="toc-number">36.</span> <span class="toc-text">Unique Paths</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rotate-List"><span class="toc-number">37.</span> <span class="toc-text">Rotate List</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Permutation-Sequence"><span class="toc-number">38.</span> <span class="toc-text">Permutation Sequence</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spiral-Matrix-II"><span class="toc-number">39.</span> <span class="toc-text">Spiral Matrix II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Length-of-Last-Word"><span class="toc-number">40.</span> <span class="toc-text">Length of Last Word</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Insert-Interval"><span class="toc-number">41.</span> <span class="toc-text">Insert Interval</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Merge-Intervals"><span class="toc-number">42.</span> <span class="toc-text">Merge Intervals</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Jump-Game"><span class="toc-number">43.</span> <span class="toc-text">Jump Game</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spiral-Matrix"><span class="toc-number">44.</span> <span class="toc-text">Spiral Matrix</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Maximum-Subarray"><span class="toc-number">45.</span> <span class="toc-text">Maximum Subarray</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#N-Queens-II"><span class="toc-number">46.</span> <span class="toc-text">N-Queens II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#N-Queens"><span class="toc-number">47.</span> <span class="toc-text">N-Queens</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pow-x-n"><span class="toc-number">48.</span> <span class="toc-text">Pow(x, n)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Anagrams"><span class="toc-number">49.</span> <span class="toc-text">Anagrams</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rotate-Image"><span class="toc-number">50.</span> <span class="toc-text">Rotate Image</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Permutations-II"><span class="toc-number">51.</span> <span class="toc-text">Permutations II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Permutations"><span class="toc-number">52.</span> <span class="toc-text">Permutations</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Jump-Game-II"><span class="toc-number">53.</span> <span class="toc-text">Jump Game II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Wildcard-Matching"><span class="toc-number">54.</span> <span class="toc-text">Wildcard Matching</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Multiply-Strings"><span class="toc-number">55.</span> <span class="toc-text">Multiply Strings</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Trapping-Rain-Water"><span class="toc-number">56.</span> <span class="toc-text">Trapping Rain Water</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#First-Missing-Positive"><span class="toc-number">57.</span> <span class="toc-text">First Missing Positive</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Combination-Sum-II"><span class="toc-number">58.</span> <span class="toc-text">Combination Sum II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Combination-Sum"><span class="toc-number">59.</span> <span class="toc-text">Combination Sum</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Count-and-Say"><span class="toc-number">60.</span> <span class="toc-text">Count and Say</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sudoku-Solver"><span class="toc-number">61.</span> <span class="toc-text">Sudoku Solver</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Valid-Sudoku"><span class="toc-number">62.</span> <span class="toc-text">Valid Sudoku</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Search-Insert-Position"><span class="toc-number">63.</span> <span class="toc-text">Search Insert Position</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Search-for-a-Range"><span class="toc-number">64.</span> <span class="toc-text">Search for a Range</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Search-in-Rotated-Sorted-Array"><span class="toc-number">65.</span> <span class="toc-text">Search in Rotated Sorted Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Longest-Valid-Parentheses"><span class="toc-number">66.</span> <span class="toc-text">Longest Valid Parentheses</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Next-Permutation"><span class="toc-number">67.</span> <span class="toc-text">Next Permutation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Substring-with-Concatenation-of-All-Words"><span class="toc-number">68.</span> <span class="toc-text">Substring with Concatenation of All Words</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Divide-Two-Integers"><span class="toc-number">69.</span> <span class="toc-text">Divide Two Integers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Implement-strStr"><span class="toc-number">70.</span> <span class="toc-text">Implement strStr()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Remove-Element"><span class="toc-number">71.</span> <span class="toc-text">Remove Element</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Remove-Duplicates-from-Sorted-Array"><span class="toc-number">72.</span> <span class="toc-text">Remove Duplicates from Sorted Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reverse-Nodes-in-k-Group"><span class="toc-number">73.</span> <span class="toc-text">Reverse Nodes in k-Group</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Swap-Nodes-in-Pairs"><span class="toc-number">74.</span> <span class="toc-text">Swap Nodes in Pairs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Merge-k-Sorted-Lists"><span class="toc-number">75.</span> <span class="toc-text">Merge k Sorted Lists</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Generate-Parentheses"><span class="toc-number">76.</span> <span class="toc-text">Generate Parentheses</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Valid-Parentheses"><span class="toc-number">77.</span> <span class="toc-text">Valid Parentheses</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Remove-Nth-Node-From-End-of-List"><span class="toc-number">78.</span> <span class="toc-text">Remove Nth Node From End of List</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Letter-Combinations-of-a-Phone-Number"><span class="toc-number">79.</span> <span class="toc-text">Letter Combinations of a Phone Number</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4Sum"><span class="toc-number">80.</span> <span class="toc-text">4Sum</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3Sum-Closest"><span class="toc-number">81.</span> <span class="toc-text">3Sum Closest</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3Sum"><span class="toc-number">82.</span> <span class="toc-text">3Sum</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Longest-Common-Prefix"><span class="toc-number">83.</span> <span class="toc-text">Longest Common Prefix</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Roman-to-Integer"><span class="toc-number">84.</span> <span class="toc-text">Roman to Integer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Integer-to-Roman"><span class="toc-number">85.</span> <span class="toc-text">Integer to Roman</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Container-With-Most-Water"><span class="toc-number">86.</span> <span class="toc-text">Container With Most Water</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Regular-Expression-Matching"><span class="toc-number">87.</span> <span class="toc-text">Regular Expression Matching</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Palindrome-Number"><span class="toc-number">88.</span> <span class="toc-text">Palindrome Number</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-to-Integer-atoi"><span class="toc-number">89.</span> <span class="toc-text">String to Integer (atoi)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reverse-Integer"><span class="toc-number">90.</span> <span class="toc-text">Reverse Integer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ZigZag-Conversion"><span class="toc-number">91.</span> <span class="toc-text">ZigZag Conversion</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Longest-Palindromic-Substring"><span class="toc-number">92.</span> <span class="toc-text">Longest Palindromic Substring</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Add-Two-Numbers"><span class="toc-number">93.</span> <span class="toc-text">Add Two Numbers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Longest-Substring-Without-Repeating-Characters"><span class="toc-number">94.</span> <span class="toc-text">Longest Substring Without Repeating Characters</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Median-of-Two-Sorted-Arrays"><span class="toc-number">95.</span> <span class="toc-text">Median of Two Sorted Arrays</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Two-Sum"><span class="toc-number">96.</span> <span class="toc-text">Two Sum</span></a></li></ol>
</div>
<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }
    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
        }
    })
    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
    }
</script>







    
      <div class="duoshuo" id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="blog/2014/03/20/leetcode-solution-02/" data-title="LeetCode题解整理版(二)" data-url="http://vimersu.win/blog/2014/03/20/leetcode-solution-02/"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:"c4fun"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = '/js/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    </script>
    <!-- 多说公共JS代码 end -->
</div>

    



    <div class="scroll" id="post-nav-button">
        
            <a href="/blog/2014/03/23/python-regular/" title="上一篇: python正则表达式">
                <i class="fa fa-angle-left"></i>
            </a>
        
        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>
        
            <a href="/blog/2014/03/18/leetcode-solution-01/" title="下一篇: LeetCode题解整理版(一) ">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>
    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/2016/07/04/dx-lesson02-3dknowledge/">DirectX 3D学习笔记02——3D数学基础</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2016/07/03/dx-lesson01-window/">DirectX 3D学习笔记01——环境搭建与窗口创建</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2015/10/03/osx-xcode-opengl/">在OSX中进行OpenGL开发</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2015/06/23/xcode64-alactraz-bug/">Xcode6.4中Alcatraz无法启动</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2015/06/23/vim-base-operation/">Vim基础操作汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2015/06/13/apache-reverse-proxy/">通过Apache反向代理访问本地Gogs服务</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2015/06/09/mac-another-screen/">Macbook修改外接显示器分辨率</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2014/12/12/how-to-use-define/">宏的拓展用法总结</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2014/12/06/cmockery/">C单元测试框架之Cmockery</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2014/10/10/maven-study/">Linux下Maven的安装与使用</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2014/05/06/python-threading/">python中的多线程</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2014/03/23/python-regular/">python正则表达式</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2014/03/20/leetcode-solution-02/">LeetCode题解整理版(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2014/03/18/leetcode-solution-01/">LeetCode题解整理版(一) </a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2014/03/12/heap-template/">一个用宏实现的堆模板</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2014/03/06/libev-study/">Libev事件库源码阅读笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2014/03/04/linux-iconv/">在Linux下使用iconv转换字符串编码</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2014/03/03/use-hexo-blog/">使用Hexo搭建个人博客</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2014/01/30/common-makefile/">一个通用的C/C++ Makefile</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2014/01/23/gnu-make-study02/">GNU Make学习总结（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2014/01/13/gnu-make-study01/">GNU Make学习总结（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2014/01/11/struct-alignment/">C的结构体字节对齐</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2013/12/02/linuxdrivecode-cdev/">Linux设备驱动学习——简单字符设备驱动的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2013/11/30/linux-sublimetext-chinese/">解决Linux下Sublime text 3的中文输入问题</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2013/11/25/start-leetcode-oj/">开始刷LeetCode OJ</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2013/11/24/octopress-generate-post-content/">让Octopress为文章自动生成目录</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2013/11/23/wlanconfig-tools-source/">wlanconfig工具分析</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2013/11/22/auto-aixiaochu-app/">Qt+BlueStack实现自动天天爱消除</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2013/11/21/binary-tree-nonrecursive-traversal/">另一种二叉树非递归遍历的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2013/11/19/linux-io-reuse-interface/">Linux中的IO复用接口简介</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2013/11/19/linux-ap-by-madwifi/">Linux下使用无线网卡搭建AP</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2013/11/19/hello-octopress/">开启OctoPress之旅</a></li></ul>
    <script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
    <script>
        $(".post-list").addClass("toc-article");
        $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
            }
        })
    </script>



    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2016 Vimer Su
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/luuman/hexo-theme-spfk" target="_blank">spfk</a> by luuman
            </div>
        </div>
        
    </div>
</footer>

    </div>
    <script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>