<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>LeetCode题解整理版(一)  | Coding 4 Fun</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="本篇题解中共55题，都是用C++写的，按照Leetcode上的顺序从上向下。可以用CTRL+F查找，如果没有的话就在题解二中。">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode题解整理版(一) ">
<meta property="og:url" content="http://vimersu.win/blog/2014/03/18/leetcode-solution-01/index.html">
<meta property="og:site_name" content="Coding 4 Fun">
<meta property="og:description" content="本篇题解中共55题，都是用C++写的，按照Leetcode上的顺序从上向下。可以用CTRL+F查找，如果没有的话就在题解二中。">
<meta property="og:updated_time" content="2016-06-04T14:57:29.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeetCode题解整理版(一) ">
<meta name="twitter:description" content="本篇题解中共55题，都是用C++写的，按照Leetcode上的顺序从上向下。可以用CTRL+F查找，如果没有的话就在题解二中。">
  
    <link rel="alternative" href="/atom.xml" title="Coding 4 Fun" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>
<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="/avator.jpg" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/">Vimer Su</a></h1>
        </hgroup>

        
        <p class="header-subtitle">Dream it, Believe it, Do IT!</p>
        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">博客首页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl mail" target="_blank" href="mailto:swm8023@gmail.com" title="mail">mail</a>
                            
                                <a class="fl github" target="_blank" href="https://github.com/swm8023" title="github">github</a>
                            
                                <a class="fl rss" target="_blank" href="/atom.xml" title="rss">rss</a>
                            
                                <a class="fl douban" target="_blank" href="https://www.douban.com/people/swm8023/" title="douban">douban</a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/AP/" style="font-size: 10px;">AP</a> <a href="/tags/Alcatraz/" style="font-size: 10px;">Alcatraz</a> <a href="/tags/Algorithm/" style="font-size: 17.5px;">Algorithm</a> <a href="/tags/Apache/" style="font-size: 10px;">Apache</a> <a href="/tags/C/" style="font-size: 15px;">C</a> <a href="/tags/Cmockery/" style="font-size: 10px;">Cmockery</a> <a href="/tags/DirectX-3D/" style="font-size: 12.5px;">DirectX 3D</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/I-O复用/" style="font-size: 10px;">I/O复用</a> <a href="/tags/Leetcode-OJ/" style="font-size: 15px;">Leetcode OJ</a> <a href="/tags/Libev/" style="font-size: 10px;">Libev</a> <a href="/tags/Linux/" style="font-size: 20px;">Linux</a> <a href="/tags/MAC/" style="font-size: 10px;">MAC</a> <a href="/tags/Makefile/" style="font-size: 15px;">Makefile</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/OSX/" style="font-size: 10px;">OSX</a> <a href="/tags/Octopress/" style="font-size: 12.5px;">Octopress</a> <a href="/tags/OpenGL/" style="font-size: 10px;">OpenGL</a> <a href="/tags/Proxy/" style="font-size: 10px;">Proxy</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Sublime-text3/" style="font-size: 10px;">Sublime text3</a> <a href="/tags/Tools/" style="font-size: 10px;">Tools</a> <a href="/tags/Vim/" style="font-size: 10px;">Vim</a> <a href="/tags/Xcode/" style="font-size: 10px;">Xcode</a> <a href="/tags/epoll/" style="font-size: 10px;">epoll</a> <a href="/tags/iconv/" style="font-size: 10px;">iconv</a> <a href="/tags/madwifi/" style="font-size: 12.5px;">madwifi</a> <a href="/tags/wlanconfig/" style="font-size: 10px;">wlanconfig</a> <a href="/tags/二叉树/" style="font-size: 10px;">二叉树</a> <a href="/tags/单元测试/" style="font-size: 10px;">单元测试</a> <a href="/tags/堆/" style="font-size: 10px;">堆</a> <a href="/tags/外接显示器/" style="font-size: 10px;">外接显示器</a> <a href="/tags/天天爱消除/" style="font-size: 10px;">天天爱消除</a> <a href="/tags/宏/" style="font-size: 10px;">宏</a> <a href="/tags/正则表达式/" style="font-size: 10px;">正则表达式</a> <a href="/tags/游戏开发/" style="font-size: 12.5px;">游戏开发</a> <a href="/tags/线程同步/" style="font-size: 10px;">线程同步</a> <a href="/tags/结构体/" style="font-size: 10px;">结构体</a> <a href="/tags/驱动程序/" style="font-size: 12.5px;">驱动程序</a>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/swm8023">swm8023@github</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.csdn.net/swm8023">swm8023@csdn</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.cnblogs.com/swm8023/">swm8023@cnblogs</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.cnblogs.com/CSGrandeur/">CSGrandeur</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://hujiaweibujidao.github.io/">Hujiawei Bujidao</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.chinaunix.net/uid/28387257.html">Henrystark&#39;s CU blog</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://oxoo.org">OxOo社</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.cnblogs.com/staginner/">Staginner</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://zhangxc.com/">张学程</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://yangha.github.io/">小阳Space</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">Hello World</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Vimer Su</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/avator.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Vimer Su</a></h1>
            </hgroup>
            
            <p class="header-subtitle">Dream it, Believe it, Do IT!</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">博客首页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="mail" target="_blank" href="mailto:swm8023@gmail.com" title="mail">mail</a>
                    
                        <a class="github" target="_blank" href="https://github.com/swm8023" title="github">github</a>
                    
                        <a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
                    
                        <a class="douban" target="_blank" href="https://www.douban.com/people/swm8023/" title="douban">douban</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap"><article id="post-leetcode-solution-01" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2014/03/18/leetcode-solution-01/" class="article-date">
      <time datetime="2014-03-18T14:07:04.000Z" itemprop="datePublished">2014-03-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      LeetCode题解整理版(一) 
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Leetcode-OJ/">Leetcode OJ</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>本篇题解中共55题，都是用C++写的，按照Leetcode上的顺序从上向下。可以用CTRL+F查找，如果没有的话就在题解二中。</p>
<a id="more"></a>
<h2 id="Evaluate-Reverse-Polish-Notation"><a href="#Evaluate-Reverse-Polish-Notation" class="headerlink" title="Evaluate Reverse Polish Notation"></a><strong>Evaluate Reverse Polish Notation</strong></h2><p>逆波兰表达式求值，经典问题。<br>遇到数字入栈，遇到符号取栈顶的两个出来运算，再将结果入栈，最后栈里剩下的一个元素就是结果了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;tokens)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// IMPORTANT: Please reset any member data you declared, as</span></span><br><span class="line">        <span class="comment">// the same Solution instance will be reused for each test case.</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;s: tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.length() &gt; <span class="number">1</span> || <span class="built_in">isdigit</span>(s[<span class="number">0</span>])) st.push(stoi(s));</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> num1 = st.top(); st.pop();</span><br><span class="line">                <span class="keyword">int</span> num2 = st.top(); st.pop();</span><br><span class="line">                <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'+'</span>) num2 += num1;</span><br><span class="line">                <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'-'</span>) num2 -= num1;</span><br><span class="line">                <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'*'</span>) num2 *= num1;</span><br><span class="line">                <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'/'</span>) num2 /= num1;</span><br><span class="line">                st.push(num2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Max-Points-on-a-Line"><a href="#Max-Points-on-a-Line" class="headerlink" title="Max Points on a Line"></a><strong>Max Points on a Line</strong></h2><p>求经过点最多的直线。<br>没想到什么好算法，枚举每个点，其它点以它为原点按斜率排序（我这里直接用MAP了，复杂度是一样的），复杂度O(n^2*logn)。这道题trick比较多，注意无斜率以及点重合的情况。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a point.</span><br><span class="line"> * struct Point &#123;</span><br><span class="line"> *     int x;</span><br><span class="line"> *     int y;</span><br><span class="line"> *     Point() : x(0), y(0) &#123;&#125;</span><br><span class="line"> *     Point(int a, int b) : x(a), y(b) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(<span class="built_in">vector</span>&lt;Point&gt; &amp;points)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// IMPORTANT: Please reset any member data you declared, as</span></span><br><span class="line">        <span class="comment">// the same Solution instance will be reused for each test case.</span></span><br><span class="line">        <span class="keyword">int</span> size = points.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, horz, same;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            mp.clear(); horz = same = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; points.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (points[j].x == points[i].x &amp;&amp; points[j].y == points[i].y) same++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (points[j].x == points[i].x) horz ++;</span><br><span class="line">                <span class="keyword">else</span> mp[(points[j].y-points[i].y)*<span class="number">1.0</span>/(points[j].x-points[i].x)]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (horz + same &gt; ans) ans = horz + same;</span><br><span class="line">            <span class="keyword">for</span> (it = mp.begin(); it != mp.end(); it++)</span><br><span class="line">                <span class="keyword">if</span> (it-&gt;second + same &gt; ans) ans = it-&gt;second + same;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Sort-List"><a href="#Sort-List" class="headerlink" title="Sort List"></a><strong>Sort List</strong></h2><p>在常数空间内使用O(nlogn)时间复杂度算法对链表排序。<br>这题写了蛮久的，首先选择排序方法，因为链表不能够随机访问，可以想到使用归并排序，由此问题简化为如何对两个有序链表进行合并。常规的归并排序需要额外的空间来存排序好的数组，而这里因为是指针，我们只要将上一个排序好的节点的next指针指到当前两个链表中较小的节点即可，这样就不在需要额外空间了。这里有一个问题，递归中我们分别处理两段的时候，这两段链表中间的指针的next可以随便改，但是头尾指针的位置是不能改的，否则在左右两段递归出来后就可能不是一个完整的链表了。我这里的处理方法比较笨拙，强制左链表第一个端点是最小的值，而后面只处理到右端点的前一个（左递归处理的是l~m-1，右递归处理的是m~r-1，一开始传进去的r是NULL）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">sortList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// IMPORTANT: Please reset any member data you declared, as</span></span><br><span class="line">        <span class="comment">// the same Solution instance will be reused for each test case.</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *tail = head;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; tail!= <span class="literal">NULL</span>; tail = tail-&gt;next, size++);</span><br><span class="line">        MergeSort(head, tail, size);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(ListNode *l, ListNode *r, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;next == r) <span class="keyword">return</span>;</span><br><span class="line">        ListNode *m = l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size / <span class="number">2</span>; i++, m = m-&gt;next);</span><br><span class="line">        MergeSort(l, m, size / <span class="number">2</span>);</span><br><span class="line">        MergeSort(m, r, size - size / <span class="number">2</span>);</span><br><span class="line">        ListNode *lp = l, *rp = m, *s;</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;val &gt; m-&gt; val) &#123;</span><br><span class="line">            swap(l-&gt;val, m-&gt;val);</span><br><span class="line">            <span class="keyword">for</span> (ListNode *t = m; t-&gt;next != r &amp;&amp; t-&gt;val &gt; t-&gt;next-&gt;val;</span><br><span class="line">                swap(t-&gt;val, t-&gt;next-&gt;val), t = t-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        s = lp, lp = lp-&gt;next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rp == r || (lp !=m &amp;&amp; lp-&gt;val &lt; rp-&gt;val))</span><br><span class="line">                s-&gt;next = lp, lp = lp-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                s-&gt;next = rp, rp = rp-&gt;next;</span><br><span class="line">            s = s-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        s-&gt;next = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span> <span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">        x^=y^=x^=y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Insertion-Sort-List"><a href="#Insertion-Sort-List" class="headerlink" title="Insertion Sort List"></a><strong>Insertion Sort List</strong></h2><p>不使用值交换实现插入排序<br>插入排序就是不断将值插入到一个有序数组中，我这里新建了一个链表作为有序链表，插入的节点依次比较到下一个节点比它大即可插入。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">insertionSortList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// IMPORTANT: Please reset any member data you declared, as</span></span><br><span class="line">        <span class="comment">// the same Solution instance will be reused for each test case.</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *newHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *nextHead = head-&gt;next, *now;</span><br><span class="line">        newHead-&gt;next = head, head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (nextHead != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            now = nextHead, nextHead = nextHead-&gt;next;</span><br><span class="line">            <span class="keyword">for</span> (ListNode *h = newHead; h != <span class="literal">NULL</span>; h = h-&gt;next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (h-&gt;next == <span class="literal">NULL</span> || now-&gt;val &lt; h-&gt;next-&gt;val) &#123;</span><br><span class="line">                    ListNode *tmp = h-&gt;next;</span><br><span class="line">                    h-&gt;next = now, now-&gt;next = tmp;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = newHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> newHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="LRU-Cache"><a href="#LRU-Cache" class="headerlink" title="LRU Cache"></a><strong>LRU Cache</strong></h2><p>LRU缓存算法实现，这个算法就是在缓存已满时，将最久未使用的元素移出缓存。<br>经典实现就是双向链表加哈希，每次使用(get or set)都使用哈希值找到这个元素在双链表中的位置，然后将它移到最前面，如果缓存已满就删除队尾的元素。哈希中放的是元素的地址，在新增、移动和删除元素的时候都要在Hash表中作对应修改，而双向链表主要是为了方便删除。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Node&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> key, val;</span><br><span class="line">    Node *pre, *next;</span><br><span class="line">    Node(<span class="keyword">int</span> k, <span class="keyword">int</span> v): key(k), val(v), pre(<span class="literal">NULL</span>), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> LRUCache&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, Node*&gt; mp;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, Node*&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">int</span> used, cap;</span><br><span class="line">    Node *head, *tail;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        mp.clear();</span><br><span class="line">        used = <span class="number">0</span>, cap = capacity;</span><br><span class="line">        head = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        head-&gt;next = tail, tail-&gt;pre = head;</span><br><span class="line">    &#125;</span><br><span class="line">    ~LRUCache()&#123;</span><br><span class="line">        <span class="keyword">for</span> (Node *n = head, *nnext; n; n = nnext) &#123;</span><br><span class="line">            nnext = n-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((iter = mp.find(key)) != mp.end()) &#123;</span><br><span class="line">            movetoFirst(iter-&gt;second);</span><br><span class="line">            <span class="keyword">return</span> iter-&gt;second-&gt;val;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((iter = mp.find(key)) != mp.end()) &#123;</span><br><span class="line">            iter-&gt;second-&gt;val = value;</span><br><span class="line">            movetoFirst(iter-&gt;second);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node *node;</span><br><span class="line">            <span class="keyword">if</span> (used == cap) &#123;</span><br><span class="line">                mp.erase(tail-&gt;pre-&gt;key);</span><br><span class="line">                node = tail-&gt;pre;</span><br><span class="line">                node-&gt;key = key, node-&gt;val = value;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">                used++;</span><br><span class="line">            &#125;</span><br><span class="line">            mp[node-&gt;key] = node;</span><br><span class="line">            movetoFirst(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">movetoFirst</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;pre &amp;&amp; node-&gt;next) &#123;</span><br><span class="line">            node-&gt;pre-&gt;next = node-&gt;next;</span><br><span class="line">            node-&gt;next-&gt;pre = node-&gt;pre;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;pre = head, node-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next-&gt;pre = node, head-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Binary-Tree-Postorder-Traversal"><a href="#Binary-Tree-Postorder-Traversal" class="headerlink" title="Binary Tree Postorder Traversal"></a><strong>Binary Tree Postorder Traversal</strong></h2><h2 id="Binary-Tree-Preorder-Traversal"><a href="#Binary-Tree-Preorder-Traversal" class="headerlink" title="Binary Tree Preorder Traversal"></a><strong>Binary Tree Preorder Traversal</strong></h2><p>二叉树的非递归遍历<br>这两道题见博文<a href="http://c4fun.cn/blog/2013/11/21/binary-tree-nonrecursive-traversal/" target="_blank" rel="external">另一种二叉树非递归遍历的实现</a>，里面对我自己的算法和传统非递归算法都进行了实现。  </p>
<h2 id="Reorder-List"><a href="#Reorder-List" class="headerlink" title="Reorder List"></a><strong>Reorder List</strong></h2><p>将链表L0→L1→…→Ln-1→Ln转变成L0→Ln→L1→Ln-1→L2→Ln-2，不能使用额外空间。<br>将后半部分链表倒置，然后轮流合并即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// IMPORTANT: Please reset any member data you declared, as</span></span><br><span class="line">        <span class="comment">// the same Solution instance will be reused for each test case.</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>, i;</span><br><span class="line">        ListNode *p, *last, *pnext, *tmp;</span><br><span class="line">        <span class="keyword">for</span> (p = head; p; p = p-&gt;next, len++);</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (p = head, i = <span class="number">0</span>; i &lt; len/<span class="number">2</span>; p = p-&gt;next, i++);</span><br><span class="line">        tmp = p, p = p-&gt;next, tmp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span> (pnext = p-&gt;next, p-&gt;next = <span class="literal">NULL</span>; pnext;) &#123;</span><br><span class="line">            tmp = pnext;</span><br><span class="line">            pnext = pnext-&gt;next;</span><br><span class="line">            tmp-&gt;next = p;</span><br><span class="line">            p = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        last = p;</span><br><span class="line">        <span class="keyword">for</span> (p = head; p; p = tmp)&#123;</span><br><span class="line">            tmp = p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (last) &#123;</span><br><span class="line">                p-&gt;next = last;</span><br><span class="line">                last = last-&gt;next;</span><br><span class="line">                p-&gt;next-&gt;next = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Linked-List-Cycle"><a href="#Linked-List-Cycle" class="headerlink" title="Linked List Cycle"></a><strong>Linked List Cycle</strong></h2><p>判断一个链表是否有环(Q形，圈圈拖个尾巴)。<br>两个指针，一个一次走一步，一个一次走两步，如果有圈必然会相遇。（都进圈后相当于追及问题，一次追一步，必然会追上而且不会错过）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// IMPORTANT: Please reset any member data you declared, as</span></span><br><span class="line">        <span class="comment">// the same Solution instance will be reused for each test case.</span></span><br><span class="line">        ListNode *h1, *h2;</span><br><span class="line">        <span class="keyword">for</span>(h1 = h2 = head; h1 &amp;&amp; h2;)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!h1-&gt;next || !h2-&gt;next || !h2-&gt;next-&gt;next)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            h1 = h1-&gt;next;</span><br><span class="line">            h2 = h2-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (h1 == h2 &amp;&amp; h1) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Linked-List-Cycle-II"><a href="#Linked-List-Cycle-II" class="headerlink" title="Linked List Cycle II"></a><strong>Linked List Cycle II</strong></h2><p>找到入环指针，就是Q形链表从尾巴进入O之后的第一个指针。<br>首先按照前一题的做法走到重合，这时再让其中一个指针回到起点，两者重新开始每次走一步，最后相遇的地方就是交点。为什么呢？假设尾巴长度为x，慢指针进入圈后走了一段弧长y，则第一次重合时，慢指针走了x+y。而快指针除了走了x+y外，还多绕了几个圈（假设多走了长度z），设圈的长度为k，则必有z=nk。快指针走的路程是慢指针的两倍，所以x+y+nk=2(x+y)，即nk=x+y。这时都回到起点，起点指针走了x步后到达交点，而这时另一个指针走了x=nk-y后也必然在交点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// IMPORTANT: Please reset any member data you declared, as</span></span><br><span class="line">        <span class="comment">// the same Solution instance will be reused for each test case.</span></span><br><span class="line">        ListNode *h1, *h2;</span><br><span class="line">        <span class="keyword">for</span>(h1 = h2 = head; h1 &amp;&amp; h2;)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!h1-&gt;next || !h2-&gt;next || !h2-&gt;next-&gt;next)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            h1 = h1-&gt;next;</span><br><span class="line">            h2 = h2-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (h1 == h2 &amp;&amp; h1) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!h1 || !h2) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        h2 = head;</span><br><span class="line">        <span class="keyword">while</span>(h1 != h2) h1 = h1-&gt;next, h2 = h2-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> h1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Word-Break"><a href="#Word-Break" class="headerlink" title="Word Break"></a><strong>Word Break</strong></h2><p>判断一个字符串是否可以拆成字典里的词。<br>DP，假设原串为<code>s[1..n]</code>，用<code>d[i][j]</code>表示<code>s[i..j]</code>是否可以有字典里的词组成，有DP方程  <code>d[i][j] = true if (d[i][k]&amp;&amp;d[k+1][j] == true,i&lt;=k&lt;j)</code><br>我写的是记忆化搜索，复杂度O（n^3）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; &amp;dict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// IMPORTANT: Please reset any member data you declared, as</span></span><br><span class="line">        <span class="comment">// the same Solution instance will be reused for each test case.</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp(s.length(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(s.length(), <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> dpit(dp, s, dict, <span class="number">0</span>, s.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dpit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;dp, <span class="built_in">string</span> &amp;s, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; &amp;dict, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[l][r] != <span class="number">-1</span>) <span class="keyword">return</span> dp[l][r];</span><br><span class="line">        <span class="keyword">if</span> (dict.find(s.substr(l, r - l + <span class="number">1</span>)) != dict.end()) <span class="keyword">return</span> dp[l][r] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dpit(dp, s, dict, l, i) &amp;&amp; dpit(dp, s, dict, i+<span class="number">1</span>, r))</span><br><span class="line">                <span class="keyword">return</span> dp[l][r] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[l][r] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Word-Break-II"><a href="#Word-Break-II" class="headerlink" title="Word Break II"></a><strong>Word Break II</strong></h2><p>上一题的加强版，需要给出所有可能的拆词方法。<br>要找出所有的拆词方法，DFS是避免不了的，但是需要剪枝来优化。<br>剪枝一：假设原串是<code>s[1...n]</code>，我们用<code>dp[i][j]=k,k&gt;0</code>表示<code>s[i..j]</code>是字典中的第k个串，这里暴力就可以了，复杂度是<code>O(∑(n+m[k]))</code>，<code>m[k]</code>表示第字典中第k个串的长度，这样在搜索的时候，可以快速判断<code>s[i..j]</code>是否在字典中，以及是字典中的哪一个词。<br>剪枝二：在搜索的时候，如果知道<code>s[i...n]</code>不能由字典中的词组成，就没必要往下搜了，这里可以用上一题的方法来DP，<code>dp[i][j]=0</code>表示不可以。  </p>
<p>PS：其实这一题可以构造出有<code>2^(n-1)</code>个解的数据，令<code>s=&quot;a..a&quot;,dict={&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,...,&quot;a..a&quot;}</code>即可，这组数据无法在多项式时间内求解。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strRes;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; seqRes;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; setVec;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; wordBreak(<span class="built_in">string</span> s, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; &amp;dict) &#123;</span><br><span class="line">        <span class="comment">// IMPORTANT: Please reset any member data you declared, as</span></span><br><span class="line">        <span class="comment">// the same Solution instance will be reused for each test case.</span></span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;::iterator iter;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp(s.length(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(s.length(), <span class="number">-1</span>));</span><br><span class="line">        setVec.clear();</span><br><span class="line">        strRes.clear();</span><br><span class="line">        seqRes.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> ds: dict) &#123;</span><br><span class="line">            setVec.push_back(ds);</span><br><span class="line">            <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((pos = s.find(ds, pos)) != <span class="built_in">string</span>::npos)</span><br><span class="line">                dp[pos][pos+ds.length()<span class="number">-1</span>] = setVec.size(), pos ++;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs_result(dp, <span class="number">0</span>, s.length()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> strRes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs_result</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;dp, <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; e) &#123;</span><br><span class="line">            <span class="built_in">string</span> s;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; seqRes.size(); i++) &#123;</span><br><span class="line">                s.append(setVec[seqRes[i] - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (i != seqRes.size() - <span class="number">1</span>) s.append(<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            strRes.push_back(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dpit(dp, s, e) == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt;= e; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[s][i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                seqRes.push_back(dp[s][i]);</span><br><span class="line">                dfs_result(dp, i + <span class="number">1</span>, e);</span><br><span class="line">                seqRes.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dpit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;dp, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[l][r] != <span class="number">-1</span>) <span class="keyword">return</span> dp[l][r];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dpit(dp, l, i) &amp;&amp; dpit(dp, i+<span class="number">1</span>, r))</span><br><span class="line">                <span class="keyword">return</span> dp[l][r] = <span class="number">-2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[l][r] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Copy-List-with-Random-Pointer"><a href="#Copy-List-with-Random-Pointer" class="headerlink" title="Copy List with Random Pointer"></a><strong>Copy List with Random Pointer</strong></h2><p>深拷贝一个链表，这个链表中除了next指针外，还有一个random指针指向链表中的某个节点。<br>当然，可以Hash原链表和新链表的地址来做，这样没有什么难度，我想到了一种不使用额外空间的做法。<br>用a表示原链表，b表示拷贝链表，a[i],b[i]分别表示a和b中的第i个节点。下面这段话可能比较绕，但是自己画一下应该很容易明白。<br>首先第一遍遍历new出<code>b[1]</code>-&gt;<code>b[n]</code>，并将<code>b[i]</code>放在<code>a[i]-&gt;random</code>中,<code>a[i]-&gt;random</code>放在<code>b[i]-&gt;next</code>中。然后第二遍遍历将<code>b[i]-&gt;random</code>指向<code>b[i]-&gt;next-&gt;random</code>（<code>b[i]-&gt;next</code>放的实际是<code>a[i]-&gt;random</code>，假设<code>a[j]=a[i]-&gt;random</code>，那<code>b[i]-&gt;next-&gt;random</code>中放的正是<code>b[j]</code>的地址！），这样就完成了<code>b[i]-&gt;random=b[j]</code>。最后，现在<code>a[i]-&gt;nex</code>t和<code>b[i]-&gt;random</code>都是正确的，而<code>a[i]-&gt;random</code>存在<code>b[i]-&gt;next</code>中，<code>b[i]-&gt;next</code>也可以通过<code>a[i]-&gt;next-&gt;random</code>得到，所以遍历一遍就可以将a和b都修复了。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// IMPORTANT: Please reset any member data you declared, as</span></span><br><span class="line">        <span class="comment">// the same Solution instance will be reused for each test case.</span></span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        RandomListNode *bhead, *anow, *bnow;</span><br><span class="line">        <span class="keyword">for</span> (anow = head; anow; anow = anow-&gt;next) &#123;</span><br><span class="line">            bnow = <span class="keyword">new</span> RandomListNode(anow-&gt;label);</span><br><span class="line">            bnow-&gt;next = anow-&gt;random;</span><br><span class="line">            anow-&gt;random = bnow;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(anow = head; anow; anow = anow-&gt;next) &#123;</span><br><span class="line">            bnow = anow-&gt;random;</span><br><span class="line">            bnow-&gt;random = bnow-&gt;next?bnow-&gt;next-&gt;random:<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bhead = head-&gt;random;</span><br><span class="line">        <span class="keyword">for</span>(anow = head; anow; anow = anow-&gt;next) &#123;</span><br><span class="line">            bnow = anow-&gt;random;</span><br><span class="line">            anow-&gt;random = bnow-&gt;next;</span><br><span class="line">            bnow-&gt;next = anow-&gt;next?anow-&gt;next-&gt;random:<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Single-Number"><a href="#Single-Number" class="headerlink" title="Single Number"></a><strong>Single Number</strong></h2><p>找出只出现了一次的数，其它数都出现两次<br>根据<code>x^x=0</code>以及<code>x^y=y^x</code>（交换律）,只要将所有数异或就完了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// IMPORTANT: Please reset any member data you declared, as</span></span><br><span class="line">        <span class="comment">// the same Solution instance will be reused for each test case.</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (--n &gt;= <span class="number">0</span>) x ^= A[n];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Single-Number-II"><a href="#Single-Number-II" class="headerlink" title="Single Number II"></a><strong>Single Number II</strong></h2><p>找出只出现了一次的数，其它数都出现三次<br>上一题的扩展，其实上一题也可以这么想，将每个数看做一个32位的二进制数，统计每一位出现1的个数，假设某个数出现两次，那就为它为1的位每个位贡献了两次。如果每个数都是两个，那每位出现1的个数必然是偶数个，假设有一个位上的1出现了奇数次，那必然有一个只出现了一次的数贡献了一个1，所以只要找到哪些位1出现了奇数次就可以找到这个数了。也是基于这种思想才用异或操作来实现的。<br>这一题虽然不能用异或操作来实现，但是还是可以根据上面这种思想来解。找出哪些位出现了<code>3n+1</code>次即可。我这里用位运算来实现的，<code>x[0]</code>表示出现<code>3n+1 or 3n+2</code>次的，<code>x[1]</code>表示出现<code>3n+2</code>次的，<code>x[2]</code>表示出现了<code>3n</code>次的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// IMPORTANT: Please reset any member data you declared, as</span></span><br><span class="line">        <span class="comment">// the same Solution instance will be reused for each test case.</span></span><br><span class="line">        <span class="keyword">int</span> x[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (--n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            x[<span class="number">2</span>] = x[<span class="number">1</span>] &amp; A[n];</span><br><span class="line">            x[<span class="number">1</span>] |= x[<span class="number">0</span>] &amp; A[n];</span><br><span class="line">            x[<span class="number">0</span>] |= A[n];</span><br><span class="line">            x[<span class="number">0</span>] &amp;= ~x[<span class="number">2</span>], x[<span class="number">1</span>] &amp;= ~x[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Candy"><a href="#Candy" class="headerlink" title="Candy"></a><strong>Candy</strong></h2><p>已知<code>a[1..n]</code>，给<code>b[1..n]</code>分配值，需满足若<code>a[i]&gt;a[j]</code>则<code>b[i]&gt;b[j]&gt;0</code>。求<code>min∑b</code>。<br>很简单，找到所有满足<code>a[i]&lt;=a[i+1]</code>且<code>a[i]&lt;=a[i-1]</code>的点，都取<code>b[i]=1</code>，然后沿着两边递增加1直到波峰即可。需要注意波峰可能会被两边上来的更新，要取较大的。<br>总的复杂度O(n)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ratings)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// IMPORTANT: Please reset any member data you declared, as</span></span><br><span class="line">        <span class="comment">// the same Solution instance will be reused for each test case.</span></span><br><span class="line">        <span class="keyword">int</span> size = ratings.size(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; candies(size, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; ratings[i] &lt;= ratings[i + <span class="number">1</span>] ||</span><br><span class="line">                i == size - <span class="number">1</span> &amp;&amp; ratings[i] &lt;= ratings[i - <span class="number">1</span>] ||</span><br><span class="line">                ratings[i] &lt;= ratings[i + <span class="number">1</span>] &amp;&amp; ratings[i] &lt;= ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;=<span class="number">0</span> &amp;&amp; ratings[j] &gt; ratings[j + <span class="number">1</span>]; j--)</span><br><span class="line">                    candies[j] = max(candies[j], candies[j + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; size &amp;&amp; ratings[j] &gt; ratings[j - <span class="number">1</span>]; j++)</span><br><span class="line">                    candies[j] = max(candies[j], candies[j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//for (int i = 0; i &lt; size; i++) printf("%d ", candies[i]);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) ans += candies[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Gas-Station"><a href="#Gas-Station" class="headerlink" title="Gas Station"></a><strong>Gas Station</strong></h2><p>n个点围成一个圈，<code>1-&gt;2..-&gt;n-&gt;1</code>，到达i点可以加油<code>gas[i]</code>，i到i+1点需要花费<code>cost[i]</code>，求是否能找到一个起点保证有油转一整圈。<br>这题还真的想了很久，想的比较复杂，其实正确的解法非常简单，我们可以依次推出以下两个结论。<br>结论一：我们用d[i][j]表示从i出发到j后剩余的油量，也就是<code>sum(gas[i]..gas[j-1])-sum(cost[i]..cost[j-1])</code>，假设依次有i,j,k三个点，如果<code>i-&gt;k</code>可以保持油量一直为正，并且<code>j-&gt;k</code>也可以保持油量一直为正，那么选择j做起点一定不如选择i做起点好，因为<code>d[i][k]= d[i][j]+d[j][k]&gt;d[j][k]</code>。  </p>
<p>根据结论一，我们假如从i点出发，到达j点后无法到达j+1点，那么i~j点都不可能作为起点，因为从这之间的任一一点出发到达j点后剩的油都不会比从i出发剩的多。<br>而下一个最佳起点必然选j+1，因为假设j+1之后有点k，那么选j+2到~k之间的任一一点都不会比j+1好，原因同上。  </p>
<p>结论二：如果总的gas大于总的cost，则必然有解。根据以上方法我们会不断更新最佳起点，假设这个序列是k1,k2..kn，有<code>d[k1][k2]&lt;0</code>,<code>d[k2][k3]&lt;0</code>…最后到达kn，我们知道kn必然是可以到达k1的，根据总gas大于总cost，有<code>d[kn][k1]+d[k1][k2]+..+d[k(n-1)][kn]&gt;0</code>，于是<code>d[kn][k1-1]&gt;-(d[k1][k2-1]+..+d[kn-1][kn])</code>，也就是说从kn走到k1后多的油量足够经过之前那些不能经过的点最终回到kn了。<br>根据以上两个结论，我们可以知道当总gas大于总cost时，kn必然是一个可行解。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;cost)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// IMPORTANT: Please reset any member data you declared, as</span></span><br><span class="line">        <span class="comment">// the same Solution instance will be reused for each test case.</span></span><br><span class="line">        <span class="keyword">int</span> remain = <span class="number">0</span>, totgas = <span class="number">0</span>, startp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gas.size(); i++) &#123;</span><br><span class="line">            remain += gas[i] - cost[i];</span><br><span class="line">            totgas += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span> (remain &lt; <span class="number">0</span>) remain = <span class="number">0</span>, startp = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        startp %= gas.size();</span><br><span class="line">        <span class="keyword">return</span> totgas &gt;= <span class="number">0</span> ? startp : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Clone-Graph"><a href="#Clone-Graph" class="headerlink" title="Clone Graph"></a><strong>Clone Graph</strong></h2><p>clone一张图<br>将原图NODE和新图NODE之间的地址MAP映射一下，然后就是遍历原图邻接表建新图就可以了。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNODE UndirectedGraphNode</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;UNODE*, UNODE*&gt;::iterator iter;</span><br><span class="line">    <span class="function">UndirectedGraphNode *<span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode *node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// IMPORTANT: Please reset any member data you declared, as</span></span><br><span class="line">        <span class="comment">// the same Solution instance will be reused for each test case.</span></span><br><span class="line">        <span class="built_in">map</span>&lt;UNODE*, UNODE* &gt; nodeMap;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> node;</span><br><span class="line">        UNODE *nnode = <span class="keyword">new</span> UNODE(node-&gt;label);</span><br><span class="line">        nodeMap[node] = nnode;</span><br><span class="line">        dfsGraph(nodeMap, node, nnode);</span><br><span class="line">        <span class="keyword">return</span> nnode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfsGraph</span><span class="params">(<span class="built_in">map</span>&lt;UNODE*, UNODE*&gt; &amp;nodeMap, UNODE *node, UNODE *nnode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node-&gt;neighbors.size(); i++) &#123;</span><br><span class="line">            UNODE *now = node-&gt;neighbors[i];</span><br><span class="line">            <span class="keyword">if</span> ((iter = nodeMap.find(now)) != nodeMap.end()) &#123;</span><br><span class="line">                 nnode-&gt;neighbors.push_back(iter-&gt;second);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                UNODE *nnow = <span class="keyword">new</span> UNODE(now-&gt;label);</span><br><span class="line">                nodeMap[now] = nnow;</span><br><span class="line">                nnode-&gt;neighbors.push_back(nnow);</span><br><span class="line">                dfsGraph(nodeMap, now, nnow);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Palindrome-Partitioning"><a href="#Palindrome-Partitioning" class="headerlink" title="Palindrome Partitioning"></a><strong>Palindrome Partitioning</strong></h2><p>划分一个字符串为，使每个子串都是回文串，返回所有划分<br>这种所有划分的必然要DFS了，只是要进行适当的剪枝。<br>预处理字符串，找出所有回文串，枚举对称轴，O(n^2)的算法。我这里用vector[i]存了所有以第i个字符开头的回文串，然后DFS到第i位的时候，只要枚举vector[i]中的字符串就可以了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; vecResult;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; partition(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="comment">// IMPORTANT: Please reset any member data you declared, as</span></span><br><span class="line">        <span class="comment">// the same Solution instance will be reused for each test case.</span></span><br><span class="line">        vecResult.clear();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vecStr;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; parStart(s.length());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; <span class="number">2</span>*i-j &lt; s.length() &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; s[j] == s[<span class="number">2</span>*i-j]; j--)</span><br><span class="line">                parStart[j].push_back(s.substr(j, <span class="number">2</span>*i<span class="number">-2</span>*j+<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; <span class="number">2</span>*i-j+<span class="number">1</span> &lt; s.length() &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; s[j] == s[<span class="number">2</span>*i-j+<span class="number">1</span>]; j--)</span><br><span class="line">                parStart[j].push_back(s.substr(j, <span class="number">2</span>*i<span class="number">-2</span>*j+<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(parStart, vecStr, <span class="number">0</span>, s.length());</span><br><span class="line">        <span class="keyword">return</span> vecResult;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; &amp;parStart, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;vecStr, <span class="keyword">int</span> sp, <span class="keyword">int</span> ep)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sp == ep) &#123;</span><br><span class="line">            vecResult.push_back(vecStr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parStart[sp].size(); i++) &#123;</span><br><span class="line">                vecStr.push_back(parStart[sp][i]);</span><br><span class="line">                dfs(parStart, vecStr, sp + parStart[sp][i].length(), ep);</span><br><span class="line">                vecStr.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Palindrome-Partitioning-II"><a href="#Palindrome-Partitioning-II" class="headerlink" title="Palindrome Partitioning II"></a><strong>Palindrome Partitioning II</strong></h2><p>划分一个字符串，使每个子串都是回文串，要求划分次数最少<br>DP，用<code>minC[i]</code>表示<code>s[1..i]</code>需要几刀，显然<code>minC[i]</code>最大是i。DP方程<br><code>minC[i] = min(i, minC[j]+1)(1&lt;=j&lt;=i&amp;&amp;isPar[j+1][i])</code>，<code>isPar[i][j]</code>在DP的过程中可以顺便求出来，<code>isPar[i][j] = true if (isPar[i+1][j-1]&amp;&amp;s[i]==s[j])</code>。<br>总的复杂度O(n^2)。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCut</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// IMPORTANT: Please reset any member data you declared, as</span></span><br><span class="line">        <span class="comment">// the same Solution instance will be reused for each test case.</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; isPar(s.length(), <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(s.length(), <span class="literal">false</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minC(s.length(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            minC[i] = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((j + <span class="number">2</span> &gt; i || isPar[j+<span class="number">1</span>][i<span class="number">-1</span>]) &amp;&amp; s[j] == s[i]) &#123;</span><br><span class="line">                    isPar[j][i] = <span class="literal">true</span>;</span><br><span class="line">                    minC[i] = min(minC[i], j ? (minC[j<span class="number">-1</span>] + <span class="number">1</span>) : <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minC[s.length() - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Surrounded-Regions"><a href="#Surrounded-Regions" class="headerlink" title="Surrounded Regions"></a><strong>Surrounded Regions</strong></h2><p>给一个n*m的由X和O组成的矩阵，要求把那些被X包围的O变成X。<br>如果有一块O其中的一个或多个接触到了外边界，就不用变成X，所以从接触边缘的O开始BFS即可，BFS到的点都不用变X。我这里用Y表示一个点原本是O并且所在块没有被X全包围。最后除了Y点其它点都变成X即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt; &amp;board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// IMPORTANT: Please reset any member data you declared, as</span></span><br><span class="line">        <span class="comment">// the same Solution instance will be reused for each test case.</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">        <span class="keyword">int</span> dx[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (board.size() == <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> lenh = board.size(), lenw = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenh; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lenw; j++)</span><br><span class="line">                <span class="keyword">if</span> ((i == <span class="number">0</span> || j == <span class="number">0</span> || i == lenh - <span class="number">1</span> || j == lenw - <span class="number">1</span>)</span><br><span class="line">                        &amp;&amp; board[i][j] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">'Y'</span>;</span><br><span class="line">                    q.push(make_pair(i, j));</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> ni = p.first + dx[i], nj = p.second + dy[i];</span><br><span class="line">                <span class="keyword">if</span> (ni &gt;= <span class="number">0</span> &amp;&amp; ni &lt; lenh &amp;&amp; nj &gt;= <span class="number">0</span> &amp;&amp; nj &lt; lenw</span><br><span class="line">                    &amp;&amp; board[ni][nj] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                    board[ni][nj] = <span class="string">'Y'</span>;</span><br><span class="line">                    q.push(make_pair(ni, nj));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenh; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lenw; j++)</span><br><span class="line">                board[i][j] = (board[i][j] == <span class="string">'Y'</span> ? <span class="string">'O'</span> : <span class="string">'X'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Sum-Root-to-Leaf-Numbers"><a href="#Sum-Root-to-Leaf-Numbers" class="headerlink" title="Sum Root to Leaf Numbers"></a><strong>Sum Root to Leaf Numbers</strong></h2><p>从根到叶的每条路径构成一个数，求这些数的和。<br>直接DFS，每次到叶子时加就可以了。其实随便一条路径长度超过9结果就超int了，想LeetCode OJ上还不至于要写BigInteger，随便用int写下果然过了。。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// IMPORTANT: Please reset any member data you declared, as</span></span><br><span class="line">        <span class="comment">// the same Solution instance will be reused for each test case.</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dfsTree(root, root-&gt;val, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfsTree</span><span class="params">(TreeNode *fa, <span class="keyword">int</span> now, <span class="keyword">int</span> &amp;ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(fa-&gt;left || fa-&gt;right)) ans += now;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fa-&gt;left) dfsTree(fa-&gt;left, now*<span class="number">10</span>+fa-&gt;left-&gt;val, ans);</span><br><span class="line">            <span class="keyword">if</span> (fa-&gt;right)dfsTree(fa-&gt;right,now*<span class="number">10</span>+fa-&gt;right-&gt;val,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Longest-Consecutive-Sequence"><a href="#Longest-Consecutive-Sequence" class="headerlink" title="Longest Consecutive Sequence"></a><strong>Longest Consecutive Sequence</strong></h2><p>再一个数组中挑出一些连续的数，求最多能挑出多少<br>想来想去也只能Hash了，把所有数都放到Hash里，重复的算一个就行。然后随意拿出一个数，以它为中心依次找比它大一的数以及小一的数，找到就擦除，然后记录它所在序列的长度。重复操作直到set为空为止。<br>感谢unordered_set，要不然还得自己写Hash。(直接用原来的set是O(nlogn)。)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// IMPORTANT: Please reset any member data you declared, as</span></span><br><span class="line">        <span class="comment">// the same Solution instance will be reused for each test case.</span></span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; uset;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.size(); i++)</span><br><span class="line">            uset.insert(num[i]);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, tmpAns = <span class="number">0</span>, now, nowb;</span><br><span class="line">        <span class="keyword">while</span> (!uset.empty()) &#123;</span><br><span class="line">            now = *uset.begin(), tmpAns = <span class="number">1</span>;</span><br><span class="line">            uset.erase(now);</span><br><span class="line">            <span class="keyword">for</span> (nowb = now + <span class="number">1</span>; uset.count(nowb); uset.erase(nowb), tmpAns++, nowb++);</span><br><span class="line">            <span class="keyword">for</span> (nowb = now - <span class="number">1</span>; uset.count(nowb); uset.erase(nowb), tmpAns++, nowb--);</span><br><span class="line">            <span class="keyword">if</span> (tmpAns &gt; ans) ans = tmpAns;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Word-Ladder"><a href="#Word-Ladder" class="headerlink" title="Word Ladder"></a><strong>Word Ladder</strong></h2><p>给出字符串S，T以及一个词典，这些字符串长度均为N，每次可以修改S中的一个字母让它变为词典中的某个词，求从S到T最少要几步。<br>边权为一的最短路，显然是BFS，我一开始使用N^2枚举建图超时了，这样复杂度是O(N^2*len)。后来想一下如果N很大的话，不如枚举改变每个字母是否可以变成字典中的某个词，复杂读是O(N*len*26)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> start, <span class="built_in">string</span> end, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; &amp;dict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// IMPORTANT: Please reset any member data you declared, as</span></span><br><span class="line">        <span class="comment">// the same Solution instance will be reused for each test case.</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; vis;</span><br><span class="line">        <span class="keyword">int</span> len = start.length();</span><br><span class="line">        q.push(start);</span><br><span class="line">        vis[start] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="built_in">string</span> s = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">int</span> step = vis[s];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="built_in">string</span> news = s;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; c++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s[i] == c) <span class="keyword">continue</span>;</span><br><span class="line">                    news[i] = c;</span><br><span class="line">                    <span class="keyword">if</span> (news == end) <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (dict.count(news) &amp;&amp; !vis[news]) &#123;</span><br><span class="line">                        vis[news] = step + <span class="number">1</span>;</span><br><span class="line">                        q.push(news);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Word-Ladder-II"><a href="#Word-Ladder-II" class="headerlink" title="Word Ladder II"></a><strong>Word Ladder II</strong></h2><p>同上，只是要打印出所有最短路径。<br>打印所有结果必然要DFS，重点是剪枝。<br>我们称在最短路径中第N次转化后得到的字符串在第N层，可以证明，如果一个字符串在最短转化A中处于第N层，那么它在最短转化B中也处于第N层，否则A和B必然有一个不是最短转化，另外，如果第N层的a节点，可以转化为N+1层的b和c节点，那么a无论走b和c，只要最后能到目标字符串，都必然是最短路。也就是说，在BFS出的树形结构中，我们可以加一些树枝表示其它最短转化的路径，但这些树枝肯定只会连接第N～N+1层的点。所以我们先BFS一遍，用邻接表的形式存从图，每次第一次扫描到一个点时记录这个点的所在层次。这样构造了图并记录了每个点的所在层次。<br>之后再从起点开始DFS,但是在相邻的点中，只走层次比自己大一的点，最后每次走到终点时将路径存入结果集即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; findLadders(<span class="built_in">string</span> start, <span class="built_in">string</span> end, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; &amp;dict) &#123;</span><br><span class="line">        <span class="comment">// IMPORTANT: Please reset any member data you declared, as</span></span><br><span class="line">        <span class="comment">// the same Solution instance will be reused for each test case.</span></span><br><span class="line">        dict.insert(end);</span><br><span class="line">        <span class="keyword">int</span> dsize = dict.size(), len = start.length();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; next;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; vis;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path;</span><br><span class="line">        ans.clear();</span><br><span class="line">        q.push(start);</span><br><span class="line">        vis[start] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="built_in">string</span> s = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span> (s == end) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> step = vis[s];</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; snext;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="built_in">string</span> news = s;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; c++) &#123;</span><br><span class="line">                    news[i] = c;</span><br><span class="line">                    <span class="keyword">if</span> (c == s[i] || dict.find(news) == dict.end()) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">auto</span> it = vis.find(news);</span><br><span class="line">                    <span class="keyword">if</span> (it == vis.end()) &#123;</span><br><span class="line">                        q.push(news);</span><br><span class="line">                        vis[news] = step + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    snext.push_back(news);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            next[s] = snext;</span><br><span class="line">        &#125;</span><br><span class="line">        path.push_back(start);</span><br><span class="line">        dfspath(path, next, vis, start, end);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfspath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;path,  <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; &amp;next,</span><br><span class="line">                 <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; &amp;vis, <span class="built_in">string</span> now, <span class="built_in">string</span> end)</span></span>&#123;</span><br><span class="line">       <span class="comment">//cout &lt;&lt; now &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (now == end) ans.push_back(path);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> vec = next[now];</span><br><span class="line">            <span class="keyword">int</span> visn = vis[now];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (vis[vec[i]] != visn + <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                path.push_back(vec[i]);</span><br><span class="line">                dfspath(path, next, vis, vec[i], end);</span><br><span class="line">                path.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Valid-Palindrome"><a href="#Valid-Palindrome" class="headerlink" title="Valid Palindrome"></a><strong>Valid Palindrome</strong></h2><p>判断是否是回文串。<br>注意只有大小写字母和数字才算作串的内容，其它字符都跳过。左右两个指针逐渐往中间逼近就可以了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// IMPORTANT: Please reset any member data you declared, as</span></span><br><span class="line">        <span class="comment">// the same Solution instance will be reused for each test case.</span></span><br><span class="line">        <span class="keyword">int</span> len = s.length(), l = <span class="number">0</span>, r = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(s[l])) l++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(s[r])) r--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">tolower</span>(s[l]) == <span class="built_in">tolower</span>(s[r])) l++, r--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Binary-Tree-Maximum-Path-Sum"><a href="#Binary-Tree-Maximum-Path-Sum" class="headerlink" title="Binary Tree Maximum Path Sum"></a><strong>Binary Tree Maximum Path Sum</strong></h2><p>在二叉树中找一条路径，路径上点和加起来最大，求最大值。<br>树形DP。首先应该知道最近公共祖先的概念，所谓最近公共祖先，就是从两个点(u,v)分别向根走，相遇的第一个点(s)，记为<code>LCA(u,v)=s</code>，那么最大权路径可以记为<code>u~s~v</code>，其中<code>u~s</code>从s的左子树上来，<code>v~s</code>从v的右子树上来，当然s可能等于u或者v。<br>然后我们用dp[x]记录以x为一个端点向下走，最大能走多少。为了公式写起来方便，先假设节点的权值都大于0。当我们走到某个点x时，有可能x就是最大权路径中的s点，那么构造出来的最长路径就是<code>dp[x[left]-&gt;val]+dp[x[right]-&gt;val]+x-&gt;val</code>，之后求出dp[x]并往上传，<code>dp[x]=x-&gt;val+max(dp[x[left]-&gt;val],dp[x[right]-&gt;val])</code>。当DP回根节点的时候，我们已经枚举了每个节点作为s时的最大权路径，取其中最大的作为结果。<br>注意如果有节点权值为负值，那么某个dp[x]可能为负，就是说宁愿不走，算做0就可以了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = root-&gt;val;</span><br><span class="line">        dfsTree(root, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfsTree</span><span class="params">(TreeNode *fa, <span class="keyword">int</span> &amp;ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fa == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = fa-&gt;val, lmax, rmax;</span><br><span class="line">        <span class="keyword">if</span> ((lmax = dfsTree(fa-&gt;left, ans)) &gt; <span class="number">0</span>) tmp += lmax;</span><br><span class="line">        <span class="keyword">if</span> ((rmax = dfsTree(fa-&gt;right, ans)) &gt; <span class="number">0</span>) tmp += rmax;</span><br><span class="line">        ans = max(ans, tmp);</span><br><span class="line">        <span class="keyword">return</span> max(fa-&gt;val, max(fa-&gt;val+lmax, fa-&gt;val+rmax));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Best-Time-to-Buy-and-Sell-Stock"><a href="#Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="Best Time to Buy and Sell Stock"></a><strong>Best Time to Buy and Sell Stock</strong></h2><p>石头的价格每天不同，可以选择一天买进，在之后某一天卖出，求最大收益。全程只能交易一次。<br>记录到i为止最低的价格，算出当天卖出的最大收益，然后取最大的就可以了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, minv = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            ans = max(ans, prices[i] - minv);</span><br><span class="line">            minv = min(minv, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Best-Time-to-Buy-and-Sell-Stock-II"><a href="#Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="Best Time to Buy and Sell Stock II"></a><strong>Best Time to Buy and Sell Stock II</strong></h2><p>与上面题面相同，只是不限买卖次数，但同一时刻只能持有一个石头。<br>贪心，记录之前最低的价格，遇到比最低价格高就卖。并从当前开始继续记录最低价格。<br>这题我并没有证明，只是想了几种情况，觉的是正确的（贪心题往往都是这样。。）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minv = prices[<span class="number">0</span>], ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &gt; minv)</span><br><span class="line">                ans += prices[i] - minv, minv = prices[i];</span><br><span class="line">            minv = min(minv, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Best-Time-to-Buy-and-Sell-Stock-III"><a href="#Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="Best Time to Buy and Sell Stock III"></a><strong>Best Time to Buy and Sell Stock III</strong></h2><p>题面与上题一样，买卖次数最多为两次，同一时刻只能持有一个石头。<br>Stock1里，我们从前向后依次能求出当天卖出一颗石头的最大收益<code>pre[i]</code>，同理，我们也能从后向前依次求出当天买入一颗石头能得到的最大收益<code>last[i]</code>，再用<code>maxlast[i]=max(last[k](i&lt;=k&lt;=n))</code>表示从i~n天内买入一颗石头的最大收益，所以，<code>ans=max(pre[i]+maxlast[i])(1&lt;=i&lt;=n)</code>，就是说再第i天完成第一笔交易，并在第i天之后的某一天完成第二笔交易。<br>总的复杂度O(n)（程序中第二次for循环的minv实际上是指从后面到当前的最大值）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = prices.size(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p(size, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> minv = prices[<span class="number">0</span>], maxv;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++)</span><br><span class="line">            p[i] = prices[i] - minv,</span><br><span class="line">            minv = min(prices[i], minv);</span><br><span class="line">        ans = max(ans, p[size<span class="number">-1</span>]);</span><br><span class="line">        minv = prices[size<span class="number">-1</span>], maxv = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            maxv = max(maxv, minv - prices[i]),</span><br><span class="line">            ans = max(ans, p[i] + maxv),</span><br><span class="line">            minv = max(prices[i], minv);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<!-- 30 here -->
<h2 id="Triangle"><a href="#Triangle" class="headerlink" title="Triangle"></a><strong>Triangle</strong></h2><p>给一个三角形数组，从顶端开始向下走，每次可以走到旁边的两个，直到底端为止，使路径上的数的和最小。<br>很经典的DP了，从下向上，每次可以从左下或右下上来，记录到当前点的最大值即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = triangle.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(triangle[size<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">                ans[j] = triangle[i][j] + min(ans[j], ans[j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Pascal’s-Triangle"><a href="#Pascal’s-Triangle" class="headerlink" title="Pascal’s Triangle"></a><strong>Pascal’s Triangle</strong></h2><p>生成杨辉三角,<code>ans[i][j] = ans[i-1][j-1] + ans[i-1][j]</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        ans.clear();</span><br><span class="line">        ans.resize(numRows);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows ;i++) &#123;</span><br><span class="line">            ans[i].resize(i+<span class="number">1</span>);</span><br><span class="line">            ans[i][<span class="number">0</span>] = ans[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">                ans[i][j] = ans[i<span class="number">-1</span>][j<span class="number">-1</span>] + ans[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Pascal’s-Triangle-II"><a href="#Pascal’s-Triangle-II" class="headerlink" title="Pascal’s Triangle II"></a><strong>Pascal’s Triangle II</strong></h2><p>生成杨辉三角第N行，第N行第i项就是二项展开式系数<code>C(N,i)</code>。<br>而<code>C(N, i)=C(N, i-1)*(N-i+1)/i</code>，递推即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getRow(<span class="keyword">int</span> rowIndex) &#123;</span><br><span class="line">        ans.resize(rowIndex + <span class="number">1</span>);</span><br><span class="line">        ans[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rowIndex; i++)</span><br><span class="line">            ans[i] = (<span class="keyword">long</span> <span class="keyword">long</span>)ans[i<span class="number">-1</span>] * (rowIndex - i + <span class="number">1</span>) / i;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Populating-Next-Right-Pointers-in-Each-Node"><a href="#Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="Populating Next Right Pointers in Each Node"></a><strong>Populating Next Right Pointers in Each Node</strong></h2><p>一棵完全二叉树，找到每个节点在这一层右边的点。<br>直接DFS，将每个点左儿子向右全部指向右儿子向左上对应的节点。比如下图DFS到1时会将2的next指向3，5指向6。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">         <span class="number">1</span></span><br><span class="line">       /   \</span><br><span class="line">      <span class="number">2</span> --&gt; <span class="number">3</span></span><br><span class="line">     / \   / \</span><br><span class="line">    <span class="number">4</span>   <span class="number">5</span>-&gt;<span class="number">6</span>  <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        connect(root-&gt;left);</span><br><span class="line">        connect(root-&gt;right);</span><br><span class="line">        <span class="keyword">for</span> (TreeLinkNode *nl = root-&gt;left, *nr = root-&gt;right; nl;</span><br><span class="line">            nl-&gt;next = nr, nl = nl-&gt;right, nr = nr-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Populating-Next-Right-Pointers-in-Each-Node-II"><a href="#Populating-Next-Right-Pointers-in-Each-Node-II" class="headerlink" title="Populating Next Right Pointers in Each Node II"></a><strong>Populating Next Right Pointers in Each Node II</strong></h2><p>与上题一样，但不是完全二叉树，并且不能用额外空间。<br>既然不能用额外空间，递归堆栈这些就直接不能用了。只能用上一层已经生成的next指针来逐层生成，代码还是有很多问题要注意的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeLinkNode *<span class="title">next</span><span class="params">(TreeLinkNode* p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; !p-&gt;left &amp;&amp; !p-&gt;right) p = p-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</span><br><span class="line">        TreeLinkNode *nextHead, *preHead, *nextPreHead;</span><br><span class="line">        <span class="keyword">for</span> (TreeLinkNode *head = root; head; preHead = head, head = nextHead) &#123;</span><br><span class="line">            head = next(head);</span><br><span class="line">            <span class="keyword">if</span> (head != <span class="literal">NULL</span>)</span><br><span class="line">                nextHead = head-&gt;left ? head-&gt;left : head-&gt;right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (preHead = <span class="literal">NULL</span>; head; preHead = head, head = next(head-&gt;next)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (head-&gt;left &amp;&amp; head-&gt;right) head-&gt;left-&gt;next = head-&gt;right;</span><br><span class="line">                <span class="keyword">if</span> (preHead) &#123;</span><br><span class="line">                    nextPreHead = head-&gt;left ? head-&gt;left : head-&gt;right;</span><br><span class="line">                    <span class="keyword">if</span> (preHead-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">                        preHead-&gt;left-&gt;next = nextPreHead;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        preHead-&gt;right-&gt;next = nextPreHead;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Distinct-Subsequences"><a href="#Distinct-Subsequences" class="headerlink" title="Distinct Subsequences"></a><strong>Distinct Subsequences</strong></h2><p>求T作为S的子串出现了多少次(不一定连续出现)<br>基础DP，<code>dp[i][j]</code>表示T[1..i]作为S[1..j]的子串出现了多少次。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lent = T.length(), lens = S.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp(lent+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(lens+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lens; i++) dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lent; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lens; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span> (S[j<span class="number">-1</span>] == T[i<span class="number">-1</span>])</span><br><span class="line">                    dp[i][j] += dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[lent][lens];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Flatten-Binary-Tree-to-Linked-List"><a href="#Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="Flatten Binary Tree to Linked List"></a><strong>Flatten Binary Tree to Linked List</strong></h2><p>树转链表<br>前序遍历，顺便把点链到链表上去。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        now = root;</span><br><span class="line">        dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode *now;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        TreeNode *right = root-&gt;right;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">            now = now-&gt;right = root-&gt;left;</span><br><span class="line">            dfs(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (right) &#123;</span><br><span class="line">            now = now-&gt;right = right;</span><br><span class="line">            dfs(right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Path-Sum"><a href="#Path-Sum" class="headerlink" title="Path Sum"></a><strong>Path Sum</strong></h2><p>求树上有没有一条从根到叶子的路节点的值加起来为N<br>DFS，到叶子判断累加值是否等于Sum<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode *root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root &amp;&amp; dfs(root, <span class="number">0</span>, sum) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode *node, <span class="keyword">int</span> now, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node -&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> now + node-&gt;val == sum ;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left &amp;&amp; dfs(node-&gt;left, now + node-&gt;val, sum)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right &amp;&amp; dfs(node-&gt;right, now + node-&gt;val, sum)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Path-Sum-II"><a href="#Path-Sum-II" class="headerlink" title="Path Sum II"></a><strong>Path Sum II</strong></h2><p>同上，只是要打印所有路径<br>一样DFS，用一个vector存路径即可<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; pathSum(TreeNode *root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        ans.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        <span class="keyword">if</span> (root) dfs(root, <span class="number">0</span>, sum) ;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *node, <span class="keyword">int</span> now, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node -&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (now + node-&gt;val == sum) &#123;</span><br><span class="line">                path.push_back(node-&gt;val);</span><br><span class="line">                ans.push_back(path);</span><br><span class="line">                path.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">            path.push_back(node-&gt;val);</span><br><span class="line">            dfs(node-&gt;left, now + node-&gt;val, sum);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">            path.push_back(node-&gt;val);</span><br><span class="line">            dfs(node-&gt;right, now + node-&gt;val, sum);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Minimum-Depth-of-Binary-Tree"><a href="#Minimum-Depth-of-Binary-Tree" class="headerlink" title="Minimum Depth of Binary Tree"></a><strong>Minimum Depth of Binary Tree</strong></h2><p>求最近的叶子深度<br>跟最大长度没什么不一样，注意处理下只有一个儿子的情况即可<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ltval = <span class="number">-1</span>, rtval = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) ltval = minDepth(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) rtval = minDepth(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+ (ltval == <span class="number">-1</span> ? rtval : (rtval == <span class="number">-1</span> ? ltval : min(ltval, rtval)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Balanced-Binary-Tree"><a href="#Balanced-Binary-Tree" class="headerlink" title="Balanced Binary Tree"></a><strong>Balanced Binary Tree</strong></h2><p>判断一棵树是否是平衡树，所谓平衡树，是指每个节点的左右孩子最大深度之差不超过1<br>DFS返回该节点的最大深度，过程中比较左孩子和右孩子为根的子树的最大深度即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> ans = <span class="literal">true</span>;</span><br><span class="line">        dfs(root, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode *root, <span class="keyword">bool</span> &amp;ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ltval = dfs(root-&gt;left, ans);</span><br><span class="line">        <span class="keyword">int</span> rtval = dfs(root-&gt;right, ans);</span><br><span class="line">        <span class="keyword">if</span> (!(ltval - rtval &lt;= <span class="number">1</span> &amp;&amp; ltval - rtval &gt;= <span class="number">-1</span>))</span><br><span class="line">            ans = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> max(ltval, rtval) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Convert-Sorted-List-to-Binary-Search-Tree"><a href="#Convert-Sorted-List-to-Binary-Search-Tree" class="headerlink" title="Convert Sorted List to Binary Search Tree"></a><strong>Convert Sorted List to Binary Search Tree</strong></h2><p>有序链表转平衡二叉树。<br>要求平衡，一半放左边，一半放右边即可，递归生成。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">sortedListToBST</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ListNode *p = head; p; p = p-&gt;next, len++);</span><br><span class="line">        <span class="keyword">return</span> dfs(head, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode *<span class="title">dfs</span><span class="params">(ListNode *head, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (len + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        ListNode *rhead = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; mid; rhead=rhead-&gt;next, i++);</span><br><span class="line">        TreeNode *node = <span class="keyword">new</span> TreeNode(rhead-&gt;val);</span><br><span class="line">        node-&gt;left = dfs(head, mid - <span class="number">1</span>);</span><br><span class="line">        node-&gt;right = dfs(rhead-&gt;next, len - mid);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Convert-Sorted-Array-to-Binary-Search-Tree"><a href="#Convert-Sorted-Array-to-Binary-Search-Tree" class="headerlink" title="Convert Sorted Array to Binary Search Tree"></a><strong>Convert Sorted Array to Binary Search Tree</strong></h2><p>有序数组转平衡二叉树。<br>和上面一样，而且还不用找中点了，更简单一些<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, num.size()<span class="number">-1</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode *<span class="title">dfs</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        TreeNode *node = <span class="keyword">new</span> TreeNode(num[mid]);</span><br><span class="line">        node-&gt;left = dfs(left, mid<span class="number">-1</span>, num);</span><br><span class="line">        node-&gt;right = dfs(mid+<span class="number">1</span>, right, num);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Binary-Tree-Level-Order-Traversal-II"><a href="#Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="Binary Tree Level Order Traversal II"></a><strong>Binary Tree Level Order Traversal II</strong></h2><p>记录树的每一层<br>BFS当然可以，我是直接DFS然后每一层一个vector存该层的数。。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vec;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; levelOrderBottom(TreeNode *root) &#123;</span><br><span class="line">        vec.clear();</span><br><span class="line">        dfs(root, <span class="number">0</span>, vec);</span><br><span class="line">        reverse(vec.begin(), vec.end());</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *root, <span class="keyword">int</span> dep, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (vec.size() &lt;= dep) vec.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        vec[dep].push_back(root-&gt;val);</span><br><span class="line">        dfs(root-&gt;left, dep+<span class="number">1</span>, vec);</span><br><span class="line">        dfs(root-&gt;right, dep+<span class="number">1</span>, vec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal"><a href="#Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal" class="headerlink" title="Construct Binary Tree from Inorder and Postorder Traversal"></a><strong>Construct Binary Tree from Inorder and Postorder Traversal</strong></h2><p>根据中序和后序序列遍历构造树<br>数据结构题，后序结构为<code>[left of x][right of x][x]</code>，中序结构为<code>[left of x][x][right of x]</code>，根据这样的结构递归构造即可<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(<span class="number">0</span>, inorder.size()<span class="number">-1</span>, <span class="number">0</span>, postorder.size()<span class="number">-1</span>, inorder, postorder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode *<span class="title">build</span><span class="params">(<span class="keyword">int</span> il, <span class="keyword">int</span> ir, <span class="keyword">int</span> pl, <span class="keyword">int</span> pr, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ivec, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;pvec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pl &gt; pr) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode *node = <span class="keyword">new</span> TreeNode(pvec[pr]);</span><br><span class="line">        <span class="keyword">int</span> ip;</span><br><span class="line">        <span class="keyword">for</span> (ip = il; ip &lt;= ir; ip++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ivec[ip] == pvec[pr]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (il&lt;=ip<span class="number">-1</span>) node-&gt;left = build(il, ip<span class="number">-1</span>, pl, pl+ip-il<span class="number">-1</span>, ivec, pvec);</span><br><span class="line">        <span class="keyword">if</span> (ip+<span class="number">1</span>&lt;=ir) node-&gt;right = build(ip+<span class="number">1</span>, ir, pl+ip-il, pr<span class="number">-1</span>, ivec, pvec);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="Construct Binary Tree from Preorder and Inorder Traversal"></a><strong>Construct Binary Tree from Preorder and Inorder Traversal</strong></h2><p>根据前序中序遍历序列构造树<br>数据结构题，前序结构为<code>[x][left of x][right of x]</code>，中序结构为<code>[left of x][x][right of x]</code>，根据这样的结构递归构造即可<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(<span class="number">0</span>, preorder.size()<span class="number">-1</span>, <span class="number">0</span>, inorder.size()<span class="number">-1</span>, preorder, inorder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode *<span class="title">build</span><span class="params">(<span class="keyword">int</span> pl, <span class="keyword">int</span> pr, <span class="keyword">int</span> il, <span class="keyword">int</span> ir, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;pvec, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ivec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pl &gt; pr) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode *node = <span class="keyword">new</span> TreeNode(pvec[pl]);</span><br><span class="line">        <span class="keyword">int</span> ip;</span><br><span class="line">        <span class="keyword">for</span> (ip = il; ip &lt;= ir; ip++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ivec[ip] == pvec[pl]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (il&lt;=ip<span class="number">-1</span>) node-&gt;left = build(pl+<span class="number">1</span>, pl+ip-il, il, ip<span class="number">-1</span>, pvec, ivec);</span><br><span class="line">        <span class="keyword">if</span> (ip+<span class="number">1</span>&lt;=ir) node-&gt;right = build(pl+ip-il+<span class="number">1</span>, pr, ip+<span class="number">1</span>, ir, pvec, ivec);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Maximum-Depth-of-Binary-Tree"><a href="#Maximum-Depth-of-Binary-Tree" class="headerlink" title="Maximum Depth of Binary Tree"></a><strong>Maximum Depth of Binary Tree</strong></h2><p>树的最大深度<br>直接DFS返回当前节点最大深度<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + max(maxDepth(root-&gt;left), maxDepth(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Binary-Tree-Zigzag-Level-Order-Traversal"><a href="#Binary-Tree-Zigzag-Level-Order-Traversal" class="headerlink" title="Binary Tree Zigzag Level Order Traversal"></a><strong>Binary Tree Zigzag Level Order Traversal</strong></h2><p>记录树的每一层，跟上面某题一样，就要前后输出顺序依次交替<br>也是DFS然后vector记录每一层，奇数层reverse一下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vec;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; zigzagLevelOrder(TreeNode *root) &#123;</span><br><span class="line">        vec.clear();</span><br><span class="line">        dfs(root, <span class="number">0</span>, vec);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; vec.size(); i += <span class="number">2</span>)</span><br><span class="line">            reverse(vec[i].begin(), vec[i].end());</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *root, <span class="keyword">int</span> dep, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (vec.size() &lt;= dep) vec.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        vec[dep].push_back(root-&gt;val);</span><br><span class="line">        dfs(root-&gt;left, dep+<span class="number">1</span>, vec);</span><br><span class="line">        dfs(root-&gt;right, dep+<span class="number">1</span>, vec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Binary-Tree-Level-Order-Traversal"><a href="#Binary-Tree-Level-Order-Traversal" class="headerlink" title="Binary Tree Level Order Traversal"></a><strong>Binary Tree Level Order Traversal</strong></h2><p>还是记录树的每一层，换个输出顺序。。<br>解法一样，vector记录每一层。。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vec;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; levelOrder(TreeNode *root) &#123;</span><br><span class="line">        vec.clear();</span><br><span class="line">        dfs(root, <span class="number">0</span>, vec);</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *root, <span class="keyword">int</span> dep, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (vec.size() &lt;= dep) vec.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        vec[dep].push_back(root-&gt;val);</span><br><span class="line">        dfs(root-&gt;left, dep+<span class="number">1</span>, vec);</span><br><span class="line">        dfs(root-&gt;right, dep+<span class="number">1</span>, vec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Symmetric-Tree"><a href="#Symmetric-Tree" class="headerlink" title="Symmetric Tree"></a><strong>Symmetric Tree</strong></h2><p>判断一棵树是不是以根为对称轴中心对称的<br>我是用vector保存下一层的节点，然后从两边向中间依次对比<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode *&gt; now, next;</span><br><span class="line">        <span class="keyword">if</span> (root) now.push_back(root);</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(now.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            next.clear();</span><br><span class="line">            <span class="keyword">int</span> size = now.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r = size - <span class="number">1</span>; l &lt;= r; l++, r--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!nodeeql(now[l]-&gt;left, now[r]-&gt;right) ||</span><br><span class="line">                    !nodeeql(now[l]-&gt;right, now[r]-&gt;left))</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now[i]-&gt;left) next.push_back(now[i]-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (now[i]-&gt;right)next.push_back(now[i]-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            now = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">nodeeql</span><span class="params">(TreeNode *l1, TreeNode *l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((!l1 &amp;&amp; l2) || (l1 &amp;&amp; !l2)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> !l1 &amp;&amp; !l2 || l1-&gt;val == l2-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Same-Tree"><a href="#Same-Tree" class="headerlink" title="Same Tree"></a><strong>Same Tree</strong></h2><p>判断两棵树是否相同<br>递归比较左子树和右子树了<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode *p, TreeNode *q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> !p &amp;&amp; !q;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val != q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(p-&gt;left, q-&gt;left) &amp;&amp;</span><br><span class="line">            isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Unique-Binary-Search-Trees"><a href="#Unique-Binary-Search-Trees" class="headerlink" title="Unique Binary Search Trees"></a><strong>Unique Binary Search Trees</strong></h2><p>计算N个节点的树有多少种<br>经典的DP了，dp[n]表示n个节点的树有dp[n]种，dp方程见代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> *dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">            dp[i] = (i &lt;= <span class="number">1</span> ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> dpit(dp, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dpit</span><span class="params">(<span class="keyword">int</span> dp[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[n] != <span class="number">-1</span>) <span class="keyword">return</span> dp[n];</span><br><span class="line">        dp[n] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            dp[n] += dpit(dp, i) * dpit(dp, n-i<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Binary-Tree-Inorder-Traversal"><a href="#Binary-Tree-Inorder-Traversal" class="headerlink" title="Binary Tree Inorder Traversal"></a><strong>Binary Tree Inorder Traversal</strong></h2><p>树的中序遍历，数据结构题，简单的遍历其实不容易写好<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode *root) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        vec.clear();</span><br><span class="line">        TreeNode *T = root;</span><br><span class="line">        <span class="keyword">while</span> (T || !st.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (T) &#123;</span><br><span class="line">                st.push(T);</span><br><span class="line">                T = T-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                T = st.top(); st.pop();</span><br><span class="line">                vec.push_back(T-&gt;val);</span><br><span class="line">                T = T-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Restore-IP-Addresses"><a href="#Restore-IP-Addresses" class="headerlink" title="Restore IP Addresses"></a><strong>Restore IP Addresses</strong></h2><p>将一个数字串转化成合法IP<br>DFS，注意一些细节<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; restoreIpAddresses(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        ans.clear();</span><br><span class="line">        dfs(ans, s, <span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;ans, <span class="built_in">string</span> s, <span class="built_in">string</span> str, <span class="keyword">int</span> pos, <span class="keyword">int</span> dep)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dep &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dep == <span class="number">4</span> &amp;&amp; pos == s.length()) ans.push_back(str);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt; s.length(); i++) &#123;</span><br><span class="line">                <span class="built_in">string</span> sub = s.substr(pos, i-pos+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (sub.length() &lt;= <span class="number">3</span> &amp;&amp; stoi(sub) &gt;= <span class="number">0</span> &amp;&amp; stoi(sub) &lt;= <span class="number">255</span> &amp;&amp;</span><br><span class="line">                    to_string(stoi(sub)) == sub) &#123;</span><br><span class="line">                    <span class="built_in">string</span> common = (dep == <span class="number">3</span> ? <span class="string">""</span>: <span class="string">"."</span>);</span><br><span class="line">                    dfs(ans, s, str+sub+common, i+<span class="number">1</span>, dep+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Simplify-Path"><a href="#Simplify-Path" class="headerlink" title="Simplify Path"></a><strong>Simplify Path</strong></h2><p>对Linux系统下的绝对路径进行简化<br>以<code>/</code>为分界，以栈来保存每一段，<code>/</code>和<code>/.</code>都没有意义，不用管，<code>/..</code>需要退栈，最后记得栈为空要加上根目录<code>/</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">simplifyPath</span><span class="params">(<span class="built_in">string</span> path)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "here" &lt;&lt; endl;</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; resVec;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>, rpos;</span><br><span class="line">        <span class="keyword">while</span> ((rpos = path.find(<span class="string">"/"</span>, pos+<span class="number">1</span>)) != <span class="built_in">string</span>::npos) &#123;</span><br><span class="line">            resVec.push_back(path.substr(pos, rpos-pos));</span><br><span class="line">            cal(resVec);</span><br><span class="line">            pos = rpos;</span><br><span class="line">        &#125;</span><br><span class="line">        resVec.push_back(path.substr(pos));</span><br><span class="line">        cal(resVec);</span><br><span class="line">        <span class="keyword">if</span> (resVec.size() == <span class="number">0</span>) resVec.push_back(<span class="string">"/"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;s: resVec) ans.append(s);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;vec)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s = vec[vec.size() - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">"/"</span> || s == <span class="string">"/."</span>) &#123;</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">"/.."</span>) &#123;</span><br><span class="line">            vec.pop_back();</span><br><span class="line">            <span class="keyword">if</span> (vec.size()) vec.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/blog/2014/03/18/leetcode-solution-01/">LeetCode题解整理版(一) </a></p>
        <p><span>文章作者:</span><a href="/" title="访问 Vimer Su 的个人博客">Vimer Su</a></p>
        <p><span>发布时间:</span>2014年03月18日 - 22时07分</p>
        <p><span>最后更新:</span>2016年06月04日 - 22时57分</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/blog/2014/03/18/leetcode-solution-01/" title="LeetCode题解整理版(一) ">http://vimersu.win/blog/2014/03/18/leetcode-solution-01/</a>
            <span class="copy-path" data-clipboard-text="原文: http://vimersu.win/blog/2014/03/18/leetcode-solution-01/　　作者: Vimer Su" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script src="/js/clipboard.min.js"></script>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target = "_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



<nav id="article-nav">
  
    <a href="/blog/2014/03/20/leetcode-solution-02/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          LeetCode题解整理版(二)
        
      </div>
    </a>
  
  
    <a href="/blog/2014/03/12/heap-template/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">一个用宏实现的堆模板</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Evaluate-Reverse-Polish-Notation"><span class="toc-number">1.</span> <span class="toc-text">Evaluate Reverse Polish Notation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Max-Points-on-a-Line"><span class="toc-number">2.</span> <span class="toc-text">Max Points on a Line</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sort-List"><span class="toc-number">3.</span> <span class="toc-text">Sort List</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Insertion-Sort-List"><span class="toc-number">4.</span> <span class="toc-text">Insertion Sort List</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LRU-Cache"><span class="toc-number">5.</span> <span class="toc-text">LRU Cache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binary-Tree-Postorder-Traversal"><span class="toc-number">6.</span> <span class="toc-text">Binary Tree Postorder Traversal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binary-Tree-Preorder-Traversal"><span class="toc-number">7.</span> <span class="toc-text">Binary Tree Preorder Traversal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reorder-List"><span class="toc-number">8.</span> <span class="toc-text">Reorder List</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linked-List-Cycle"><span class="toc-number">9.</span> <span class="toc-text">Linked List Cycle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linked-List-Cycle-II"><span class="toc-number">10.</span> <span class="toc-text">Linked List Cycle II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Word-Break"><span class="toc-number">11.</span> <span class="toc-text">Word Break</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Word-Break-II"><span class="toc-number">12.</span> <span class="toc-text">Word Break II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Copy-List-with-Random-Pointer"><span class="toc-number">13.</span> <span class="toc-text">Copy List with Random Pointer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Single-Number"><span class="toc-number">14.</span> <span class="toc-text">Single Number</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Single-Number-II"><span class="toc-number">15.</span> <span class="toc-text">Single Number II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Candy"><span class="toc-number">16.</span> <span class="toc-text">Candy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Gas-Station"><span class="toc-number">17.</span> <span class="toc-text">Gas Station</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Clone-Graph"><span class="toc-number">18.</span> <span class="toc-text">Clone Graph</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Palindrome-Partitioning"><span class="toc-number">19.</span> <span class="toc-text">Palindrome Partitioning</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Palindrome-Partitioning-II"><span class="toc-number">20.</span> <span class="toc-text">Palindrome Partitioning II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Surrounded-Regions"><span class="toc-number">21.</span> <span class="toc-text">Surrounded Regions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sum-Root-to-Leaf-Numbers"><span class="toc-number">22.</span> <span class="toc-text">Sum Root to Leaf Numbers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Longest-Consecutive-Sequence"><span class="toc-number">23.</span> <span class="toc-text">Longest Consecutive Sequence</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Word-Ladder"><span class="toc-number">24.</span> <span class="toc-text">Word Ladder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Word-Ladder-II"><span class="toc-number">25.</span> <span class="toc-text">Word Ladder II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Valid-Palindrome"><span class="toc-number">26.</span> <span class="toc-text">Valid Palindrome</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binary-Tree-Maximum-Path-Sum"><span class="toc-number">27.</span> <span class="toc-text">Binary Tree Maximum Path Sum</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Best-Time-to-Buy-and-Sell-Stock"><span class="toc-number">28.</span> <span class="toc-text">Best Time to Buy and Sell Stock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Best-Time-to-Buy-and-Sell-Stock-II"><span class="toc-number">29.</span> <span class="toc-text">Best Time to Buy and Sell Stock II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Best-Time-to-Buy-and-Sell-Stock-III"><span class="toc-number">30.</span> <span class="toc-text">Best Time to Buy and Sell Stock III</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Triangle"><span class="toc-number">31.</span> <span class="toc-text">Triangle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pascal’s-Triangle"><span class="toc-number">32.</span> <span class="toc-text">Pascal’s Triangle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pascal’s-Triangle-II"><span class="toc-number">33.</span> <span class="toc-text">Pascal’s Triangle II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Populating-Next-Right-Pointers-in-Each-Node"><span class="toc-number">34.</span> <span class="toc-text">Populating Next Right Pointers in Each Node</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Populating-Next-Right-Pointers-in-Each-Node-II"><span class="toc-number">35.</span> <span class="toc-text">Populating Next Right Pointers in Each Node II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Distinct-Subsequences"><span class="toc-number">36.</span> <span class="toc-text">Distinct Subsequences</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Flatten-Binary-Tree-to-Linked-List"><span class="toc-number">37.</span> <span class="toc-text">Flatten Binary Tree to Linked List</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Path-Sum"><span class="toc-number">38.</span> <span class="toc-text">Path Sum</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Path-Sum-II"><span class="toc-number">39.</span> <span class="toc-text">Path Sum II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Minimum-Depth-of-Binary-Tree"><span class="toc-number">40.</span> <span class="toc-text">Minimum Depth of Binary Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Balanced-Binary-Tree"><span class="toc-number">41.</span> <span class="toc-text">Balanced Binary Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Convert-Sorted-List-to-Binary-Search-Tree"><span class="toc-number">42.</span> <span class="toc-text">Convert Sorted List to Binary Search Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Convert-Sorted-Array-to-Binary-Search-Tree"><span class="toc-number">43.</span> <span class="toc-text">Convert Sorted Array to Binary Search Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binary-Tree-Level-Order-Traversal-II"><span class="toc-number">44.</span> <span class="toc-text">Binary Tree Level Order Traversal II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal"><span class="toc-number">45.</span> <span class="toc-text">Construct Binary Tree from Inorder and Postorder Traversal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><span class="toc-number">46.</span> <span class="toc-text">Construct Binary Tree from Preorder and Inorder Traversal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Maximum-Depth-of-Binary-Tree"><span class="toc-number">47.</span> <span class="toc-text">Maximum Depth of Binary Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binary-Tree-Zigzag-Level-Order-Traversal"><span class="toc-number">48.</span> <span class="toc-text">Binary Tree Zigzag Level Order Traversal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binary-Tree-Level-Order-Traversal"><span class="toc-number">49.</span> <span class="toc-text">Binary Tree Level Order Traversal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Symmetric-Tree"><span class="toc-number">50.</span> <span class="toc-text">Symmetric Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Same-Tree"><span class="toc-number">51.</span> <span class="toc-text">Same Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unique-Binary-Search-Trees"><span class="toc-number">52.</span> <span class="toc-text">Unique Binary Search Trees</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binary-Tree-Inorder-Traversal"><span class="toc-number">53.</span> <span class="toc-text">Binary Tree Inorder Traversal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Restore-IP-Addresses"><span class="toc-number">54.</span> <span class="toc-text">Restore IP Addresses</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Simplify-Path"><span class="toc-number">55.</span> <span class="toc-text">Simplify Path</span></a></li></ol>
</div>
<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }
    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
        }
    })
    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
    }
</script>







    
      <div class="duoshuo" id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="blog/2014/03/18/leetcode-solution-01/" data-title="LeetCode题解整理版(一) " data-url="http://vimersu.win/blog/2014/03/18/leetcode-solution-01/"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:"c4fun"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = '/js/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    </script>
    <!-- 多说公共JS代码 end -->
</div>

    



    <div class="scroll" id="post-nav-button">
        
            <a href="/blog/2014/03/20/leetcode-solution-02/" title="上一篇: LeetCode题解整理版(二)">
                <i class="fa fa-angle-left"></i>
            </a>
        
        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>
        
            <a href="/blog/2014/03/12/heap-template/" title="下一篇: 一个用宏实现的堆模板">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>
    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/2016/07/04/dx-lesson02-3dknowledge/">DirectX 3D学习笔记02——3D数学基础</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2016/07/03/dx-lesson01-window/">DirectX 3D学习笔记01——环境搭建与窗口创建</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2015/10/03/osx-xcode-opengl/">在OSX中进行OpenGL开发</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2015/06/23/xcode64-alactraz-bug/">Xcode6.4中Alcatraz无法启动</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2015/06/23/vim-base-operation/">Vim基础操作汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2015/06/13/apache-reverse-proxy/">通过Apache反向代理访问本地Gogs服务</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2015/06/09/mac-another-screen/">Macbook修改外接显示器分辨率</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2014/12/12/how-to-use-define/">宏的拓展用法总结</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2014/12/06/cmockery/">C单元测试框架之Cmockery</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2014/10/10/maven-study/">Linux下Maven的安装与使用</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2014/05/06/python-threading/">python中的多线程</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2014/03/23/python-regular/">python正则表达式</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2014/03/20/leetcode-solution-02/">LeetCode题解整理版(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2014/03/18/leetcode-solution-01/">LeetCode题解整理版(一) </a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2014/03/12/heap-template/">一个用宏实现的堆模板</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2014/03/06/libev-study/">Libev事件库源码阅读笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2014/03/04/linux-iconv/">在Linux下使用iconv转换字符串编码</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2014/03/03/use-hexo-blog/">使用Hexo搭建个人博客</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2014/01/30/common-makefile/">一个通用的C/C++ Makefile</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2014/01/23/gnu-make-study02/">GNU Make学习总结（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2014/01/13/gnu-make-study01/">GNU Make学习总结（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2014/01/11/struct-alignment/">C的结构体字节对齐</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2013/12/02/linuxdrivecode-cdev/">Linux设备驱动学习——简单字符设备驱动的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2013/11/30/linux-sublimetext-chinese/">解决Linux下Sublime text 3的中文输入问题</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2013/11/25/start-leetcode-oj/">开始刷LeetCode OJ</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2013/11/24/octopress-generate-post-content/">让Octopress为文章自动生成目录</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2013/11/23/wlanconfig-tools-source/">wlanconfig工具分析</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2013/11/22/auto-aixiaochu-app/">Qt+BlueStack实现自动天天爱消除</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2013/11/21/binary-tree-nonrecursive-traversal/">另一种二叉树非递归遍历的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2013/11/19/linux-io-reuse-interface/">Linux中的IO复用接口简介</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2013/11/19/linux-ap-by-madwifi/">Linux下使用无线网卡搭建AP</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2013/11/19/hello-octopress/">开启OctoPress之旅</a></li></ul>
    <script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
    <script>
        $(".post-list").addClass("toc-article");
        $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
            }
        })
    </script>



    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2016 Vimer Su
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/luuman/hexo-theme-spfk" target="_blank">spfk</a> by luuman
            </div>
        </div>
        
    </div>
</footer>

    </div>
    <script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>